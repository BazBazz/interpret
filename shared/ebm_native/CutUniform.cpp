// Copyright (c) 2018 Microsoft Corporation
// Licensed under the MIT license.
// Author: Paul Koch <code@koch.ninja>

#include "precompiled_header_cpp.hpp"

#include <stddef.h> // size_t, ptrdiff_t
#include <limits> // std::numeric_limits

#include "ebm_native.h"
#include "logging.h"
#include "zones.h"

#include "ebm_internal.hpp"

namespace DEFINED_ZONE_NAME {
#ifndef DEFINED_ZONE_NAME
#error DEFINED_ZONE_NAME must be defined
#endif // DEFINED_ZONE_NAME

static const double Tick1To0[1022] {
   /* GENERATED WITH:
      double low = 1.0 * k_subnormToNorm * 0.5;
      low *= 0.5; // first one goes in the variable
      do {
         printf("   %.16le,\n", nextafter(low, 0.0));
         low *= 0.5;
      } while(DBL_MIN * k_subnormToNorm < low);
      printf("   %.16le\n", 0.0);
   */
   1.1258999068426239e+15,
   5.6294995342131194e+14,
   2.8147497671065597e+14,
   1.4073748835532798e+14,
   7.0368744177663992e+13,
   3.5184372088831996e+13,
   1.7592186044415998e+13,
   8.7960930222079990e+12,
   4.3980465111039995e+12,
   2.1990232555519998e+12,
   1.0995116277759999e+12,
   5.4975581388799994e+11,
   2.7487790694399997e+11,
   1.3743895347199998e+11,
   6.8719476735999992e+10,
   3.4359738367999996e+10,
   1.7179869183999998e+10,
   8.5899345919999990e+09,
   4.2949672959999995e+09,
   2.1474836479999998e+09,
   1.0737418239999999e+09,
   5.3687091199999994e+08,
   2.6843545599999997e+08,
   1.3421772799999999e+08,
   6.7108863999999993e+07,
   3.3554431999999996e+07,
   1.6777215999999998e+07,
   8.3886079999999991e+06,
   4.1943039999999995e+06,
   2.0971519999999998e+06,
   1.0485759999999999e+06,
   5.2428799999999994e+05,
   2.6214399999999997e+05,
   1.3107199999999999e+05,
   6.5535999999999993e+04,
   3.2767999999999996e+04,
   1.6383999999999998e+04,
   8.1919999999999991e+03,
   4.0959999999999995e+03,
   2.0479999999999998e+03,
   1.0239999999999999e+03,
   5.1199999999999994e+02,
   2.5599999999999997e+02,
   1.2799999999999999e+02,
   6.3999999999999993e+01,
   3.1999999999999996e+01,
   1.5999999999999998e+01,
   7.9999999999999991e+00,
   3.9999999999999996e+00,
   1.9999999999999998e+00,
   9.9999999999999989e-01,
   4.9999999999999994e-01,
   2.4999999999999997e-01,
   1.2499999999999999e-01,
   6.2499999999999993e-02,
   3.1249999999999997e-02,
   1.5624999999999998e-02,
   7.8124999999999991e-03,
   3.9062499999999996e-03,
   1.9531249999999998e-03,
   9.7656249999999989e-04,
   4.8828124999999995e-04,
   2.4414062499999997e-04,
   1.2207031249999999e-04,
   6.1035156249999993e-05,
   3.0517578124999997e-05,
   1.5258789062499998e-05,
   7.6293945312499992e-06,
   3.8146972656249996e-06,
   1.9073486328124998e-06,
   9.5367431640624989e-07,
   4.7683715820312495e-07,
   2.3841857910156247e-07,
   1.1920928955078124e-07,
   5.9604644775390618e-08,
   2.9802322387695309e-08,
   1.4901161193847655e-08,
   7.4505805969238273e-09,
   3.7252902984619136e-09,
   1.8626451492309568e-09,
   9.3132257461547841e-10,
   4.6566128730773921e-10,
   2.3283064365386960e-10,
   1.1641532182693480e-10,
   5.8207660913467401e-11,
   2.9103830456733700e-11,
   1.4551915228366850e-11,
   7.2759576141834251e-12,
   3.6379788070917125e-12,
   1.8189894035458563e-12,
   9.0949470177292814e-13,
   4.5474735088646407e-13,
   2.2737367544323203e-13,
   1.1368683772161602e-13,
   5.6843418860808009e-14,
   2.8421709430404004e-14,
   1.4210854715202002e-14,
   7.1054273576010011e-15,
   3.5527136788005005e-15,
   1.7763568394002503e-15,
   8.8817841970012513e-16,
   4.4408920985006257e-16,
   2.2204460492503128e-16,
   1.1102230246251564e-16,
   5.5511151231257821e-17,
   2.7755575615628910e-17,
   1.3877787807814455e-17,
   6.9388939039072276e-18,
   3.4694469519536138e-18,
   1.7347234759768069e-18,
   8.6736173798840345e-19,
   4.3368086899420173e-19,
   2.1684043449710086e-19,
   1.0842021724855043e-19,
   5.4210108624275216e-20,
   2.7105054312137608e-20,
   1.3552527156068804e-20,
   6.7762635780344020e-21,
   3.3881317890172010e-21,
   1.6940658945086005e-21,
   8.4703294725430025e-22,
   4.2351647362715012e-22,
   2.1175823681357506e-22,
   1.0587911840678753e-22,
   5.2939559203393765e-23,
   2.6469779601696883e-23,
   1.3234889800848441e-23,
   6.6174449004242207e-24,
   3.3087224502121103e-24,
   1.6543612251060552e-24,
   8.2718061255302758e-25,
   4.1359030627651379e-25,
   2.0679515313825690e-25,
   1.0339757656912845e-25,
   5.1698788284564224e-26,
   2.5849394142282112e-26,
   1.2924697071141056e-26,
   6.4623485355705280e-27,
   3.2311742677852640e-27,
   1.6155871338926320e-27,
   8.0779356694631600e-28,
   4.0389678347315800e-28,
   2.0194839173657900e-28,
   1.0097419586828950e-28,
   5.0487097934144750e-29,
   2.5243548967072375e-29,
   1.2621774483536187e-29,
   6.3108872417680937e-30,
   3.1554436208840469e-30,
   1.5777218104420234e-30,
   7.8886090522101172e-31,
   3.9443045261050586e-31,
   1.9721522630525293e-31,
   9.8607613152626465e-32,
   4.9303806576313232e-32,
   2.4651903288156616e-32,
   1.2325951644078308e-32,
   6.1629758220391540e-33,
   3.0814879110195770e-33,
   1.5407439555097885e-33,
   7.7037197775489426e-34,
   3.8518598887744713e-34,
   1.9259299443872356e-34,
   9.6296497219361782e-35,
   4.8148248609680891e-35,
   2.4074124304840445e-35,
   1.2037062152420223e-35,
   6.0185310762101114e-36,
   3.0092655381050557e-36,
   1.5046327690525278e-36,
   7.5231638452626392e-37,
   3.7615819226313196e-37,
   1.8807909613156598e-37,
   9.4039548065782990e-38,
   4.7019774032891495e-38,
   2.3509887016445748e-38,
   1.1754943508222874e-38,
   5.8774717541114369e-39,
   2.9387358770557184e-39,
   1.4693679385278592e-39,
   7.3468396926392961e-40,
   3.6734198463196481e-40,
   1.8367099231598240e-40,
   9.1835496157991201e-41,
   4.5917748078995601e-41,
   2.2958874039497800e-41,
   1.1479437019748900e-41,
   5.7397185098744501e-42,
   2.8698592549372250e-42,
   1.4349296274686125e-42,
   7.1746481373430626e-43,
   3.5873240686715313e-43,
   1.7936620343357657e-43,
   8.9683101716788283e-44,
   4.4841550858394141e-44,
   2.2420775429197071e-44,
   1.1210387714598535e-44,
   5.6051938572992677e-45,
   2.8025969286496338e-45,
   1.4012984643248169e-45,
   7.0064923216240846e-46,
   3.5032461608120423e-46,
   1.7516230804060211e-46,
   8.7581154020301057e-47,
   4.3790577010150529e-47,
   2.1895288505075264e-47,
   1.0947644252537632e-47,
   5.4738221262688161e-48,
   2.7369110631344080e-48,
   1.3684555315672040e-48,
   6.8422776578360201e-49,
   3.4211388289180100e-49,
   1.7105694144590050e-49,
   8.5528470722950251e-50,
   4.2764235361475126e-50,
   2.1382117680737563e-50,
   1.0691058840368781e-50,
   5.3455294201843907e-51,
   2.6727647100921953e-51,
   1.3363823550460977e-51,
   6.6819117752304884e-52,
   3.3409558876152442e-52,
   1.6704779438076221e-52,
   8.3523897190381105e-53,
   4.1761948595190552e-53,
   2.0880974297595276e-53,
   1.0440487148797638e-53,
   5.2202435743988190e-54,
   2.6101217871994095e-54,
   1.3050608935997048e-54,
   6.5253044679985238e-55,
   3.2626522339992619e-55,
   1.6313261169996310e-55,
   8.1566305849981548e-56,
   4.0783152924990774e-56,
   2.0391576462495387e-56,
   1.0195788231247693e-56,
   5.0978941156238467e-57,
   2.5489470578119234e-57,
   1.2744735289059617e-57,
   6.3723676445298084e-58,
   3.1861838222649042e-58,
   1.5930919111324521e-58,
   7.9654595556622605e-59,
   3.9827297778311303e-59,
   1.9913648889155651e-59,
   9.9568244445778256e-60,
   4.9784122222889128e-60,
   2.4892061111444564e-60,
   1.2446030555722282e-60,
   6.2230152778611410e-61,
   3.1115076389305705e-61,
   1.5557538194652853e-61,
   7.7787690973264263e-62,
   3.8893845486632131e-62,
   1.9446922743316066e-62,
   9.7234613716580328e-63,
   4.8617306858290164e-63,
   2.4308653429145082e-63,
   1.2154326714572541e-63,
   6.0771633572862705e-64,
   3.0385816786431353e-64,
   1.5192908393215676e-64,
   7.5964541966078382e-65,
   3.7982270983039191e-65,
   1.8991135491519595e-65,
   9.4955677457597977e-66,
   4.7477838728798988e-66,
   2.3738919364399494e-66,
   1.1869459682199747e-66,
   5.9347298410998736e-67,
   2.9673649205499368e-67,
   1.4836824602749684e-67,
   7.4184123013748419e-68,
   3.7092061506874210e-68,
   1.8546030753437105e-68,
   9.2730153767185524e-69,
   4.6365076883592762e-69,
   2.3182538441796381e-69,
   1.1591269220898191e-69,
   5.7956346104490953e-70,
   2.8978173052245476e-70,
   1.4489086526122738e-70,
   7.2445432630613691e-71,
   3.6222716315306845e-71,
   1.8111358157653423e-71,
   9.0556790788267114e-72,
   4.5278395394133557e-72,
   2.2639197697066778e-72,
   1.1319598848533389e-72,
   5.6597994242666946e-73,
   2.8298997121333473e-73,
   1.4149498560666737e-73,
   7.0747492803333683e-74,
   3.5373746401666841e-74,
   1.7686873200833421e-74,
   8.8434366004167103e-75,
   4.4217183002083552e-75,
   2.2108591501041776e-75,
   1.1054295750520888e-75,
   5.5271478752604439e-76,
   2.7635739376302220e-76,
   1.3817869688151110e-76,
   6.9089348440755549e-77,
   3.4544674220377775e-77,
   1.7272337110188887e-77,
   8.6361685550944437e-78,
   4.3180842775472218e-78,
   2.1590421387736109e-78,
   1.0795210693868055e-78,
   5.3976053469340273e-79,
   2.6988026734670136e-79,
   1.3494013367335068e-79,
   6.7470066836675341e-80,
   3.3735033418337671e-80,
   1.6867516709168835e-80,
   8.4337583545844176e-81,
   4.2168791772922088e-81,
   2.1084395886461044e-81,
   1.0542197943230522e-81,
   5.2710989716152610e-82,
   2.6355494858076305e-82,
   1.3177747429038153e-82,
   6.5888737145190763e-83,
   3.2944368572595381e-83,
   1.6472184286297691e-83,
   8.2360921431488454e-84,
   4.1180460715744227e-84,
   2.0590230357872113e-84,
   1.0295115178936057e-84,
   5.1475575894680283e-85,
   2.5737787947340142e-85,
   1.2868893973670071e-85,
   6.4344469868350354e-86,
   3.2172234934175177e-86,
   1.6086117467087589e-86,
   8.0430587335437943e-87,
   4.0215293667718971e-87,
   2.0107646833859486e-87,
   1.0053823416929743e-87,
   5.0269117084648714e-88,
   2.5134558542324357e-88,
   1.2567279271162179e-88,
   6.2836396355810893e-89,
   3.1418198177905446e-89,
   1.5709099088952723e-89,
   7.8545495444763616e-90,
   3.9272747722381808e-90,
   1.9636373861190904e-90,
   9.8181869305954520e-91,
   4.9090934652977260e-91,
   2.4545467326488630e-91,
   1.2272733663244315e-91,
   6.1363668316221575e-92,
   3.0681834158110788e-92,
   1.5340917079055394e-92,
   7.6704585395276969e-93,
   3.8352292697638484e-93,
   1.9176146348819242e-93,
   9.5880731744096211e-94,
   4.7940365872048106e-94,
   2.3970182936024053e-94,
   1.1985091468012026e-94,
   5.9925457340060132e-95,
   2.9962728670030066e-95,
   1.4981364335015033e-95,
   7.4906821675075165e-96,
   3.7453410837537582e-96,
   1.8726705418768791e-96,
   9.3633527093843956e-97,
   4.6816763546921978e-97,
   2.3408381773460989e-97,
   1.1704190886730495e-97,
   5.8520954433652473e-98,
   2.9260477216826236e-98,
   1.4630238608413118e-98,
   7.3151193042065591e-99,
   3.6575596521032795e-99,
   1.8287798260516398e-99,
   9.1438991302581988e-100,
   4.5719495651290994e-100,
   2.2859747825645497e-100,
   1.1429873912822749e-100,
   5.7149369564113743e-101,
   2.8574684782056871e-101,
   1.4287342391028436e-101,
   7.1436711955142178e-102,
   3.5718355977571089e-102,
   1.7859177988785545e-102,
   8.9295889943927723e-103,
   4.4647944971963862e-103,
   2.2323972485981931e-103,
   1.1161986242990965e-103,
   5.5809931214954827e-104,
   2.7904965607477413e-104,
   1.3952482803738707e-104,
   6.9762414018693534e-105,
   3.4881207009346767e-105,
   1.7440603504673383e-105,
   8.7203017523366917e-106,
   4.3601508761683459e-106,
   2.1800754380841729e-106,
   1.0900377190420865e-106,
   5.4501885952104323e-107,
   2.7250942976052162e-107,
   1.3625471488026081e-107,
   6.8127357440130404e-108,
   3.4063678720065202e-108,
   1.7031839360032601e-108,
   8.5159196800163005e-109,
   4.2579598400081502e-109,
   2.1289799200040751e-109,
   1.0644899600020376e-109,
   5.3224498000101878e-110,
   2.6612249000050939e-110,
   1.3306124500025470e-110,
   6.6530622500127348e-111,
   3.3265311250063674e-111,
   1.6632655625031837e-111,
   8.3163278125159185e-112,
   4.1581639062579592e-112,
   2.0790819531289796e-112,
   1.0395409765644898e-112,
   5.1977048828224490e-113,
   2.5988524414112245e-113,
   1.2994262207056123e-113,
   6.4971311035280613e-114,
   3.2485655517640306e-114,
   1.6242827758820153e-114,
   8.1214138794100766e-115,
   4.0607069397050383e-115,
   2.0303534698525192e-115,
   1.0151767349262596e-115,
   5.0758836746312979e-116,
   2.5379418373156489e-116,
   1.2689709186578245e-116,
   6.3448545932891224e-117,
   3.1724272966445612e-117,
   1.5862136483222806e-117,
   7.9310682416114029e-118,
   3.9655341208057015e-118,
   1.9827670604028507e-118,
   9.9138353020142537e-119,
   4.9569176510071268e-119,
   2.4784588255035634e-119,
   1.2392294127517817e-119,
   6.1961470637589085e-120,
   3.0980735318794543e-120,
   1.5490367659397271e-120,
   7.7451838296986357e-121,
   3.8725919148493178e-121,
   1.9362959574246589e-121,
   9.6814797871232946e-122,
   4.8407398935616473e-122,
   2.4203699467808237e-122,
   1.2101849733904118e-122,
   6.0509248669520591e-123,
   3.0254624334760296e-123,
   1.5127312167380148e-123,
   7.5636560836900739e-124,
   3.7818280418450370e-124,
   1.8909140209225185e-124,
   9.4545701046125924e-125,
   4.7272850523062962e-125,
   2.3636425261531481e-125,
   1.1818212630765740e-125,
   5.9091063153828702e-126,
   2.9545531576914351e-126,
   1.4772765788457176e-126,
   7.3863828942285878e-127,
   3.6931914471142939e-127,
   1.8465957235571470e-127,
   9.2329786177857348e-128,
   4.6164893088928674e-128,
   2.3082446544464337e-128,
   1.1541223272232168e-128,
   5.7706116361160842e-129,
   2.8853058180580421e-129,
   1.4426529090290211e-129,
   7.2132645451451053e-130,
   3.6066322725725526e-130,
   1.8033161362862763e-130,
   9.0165806814313816e-131,
   4.5082903407156908e-131,
   2.2541451703578454e-131,
   1.1270725851789227e-131,
   5.6353629258946135e-132,
   2.8176814629473067e-132,
   1.4088407314736534e-132,
   7.0442036573682669e-133,
   3.5221018286841334e-133,
   1.7610509143420667e-133,
   8.8052545717103336e-134,
   4.4026272858551668e-134,
   2.2013136429275834e-134,
   1.1006568214637917e-134,
   5.5032841073189585e-135,
   2.7516420536594792e-135,
   1.3758210268297396e-135,
   6.8791051341486981e-136,
   3.4395525670743491e-136,
   1.7197762835371745e-136,
   8.5988814176858726e-137,
   4.2994407088429363e-137,
   2.1497203544214682e-137,
   1.0748601772107341e-137,
   5.3743008860536704e-138,
   2.6871504430268352e-138,
   1.3435752215134176e-138,
   6.7178761075670880e-139,
   3.3589380537835440e-139,
   1.6794690268917720e-139,
   8.3973451344588600e-140,
   4.1986725672294300e-140,
   2.0993362836147150e-140,
   1.0496681418073575e-140,
   5.2483407090367875e-141,
   2.6241703545183938e-141,
   1.3120851772591969e-141,
   6.5604258862959844e-142,
   3.2802129431479922e-142,
   1.6401064715739961e-142,
   8.2005323578699805e-143,
   4.1002661789349902e-143,
   2.0501330894674951e-143,
   1.0250665447337476e-143,
   5.1253327236687378e-144,
   2.5626663618343689e-144,
   1.2813331809171844e-144,
   6.4066659045859222e-145,
   3.2033329522929611e-145,
   1.6016664761464806e-145,
   8.0083323807324028e-146,
   4.0041661903662014e-146,
   2.0020830951831007e-146,
   1.0010415475915504e-146,
   5.0052077379577518e-147,
   2.5026038689788759e-147,
   1.2513019344894379e-147,
   6.2565096724471897e-148,
   3.1282548362235948e-148,
   1.5641274181117974e-148,
   7.8206370905589871e-149,
   3.9103185452794936e-149,
   1.9551592726397468e-149,
   9.7757963631987339e-150,
   4.8878981815993669e-150,
   2.4439490907996835e-150,
   1.2219745453998417e-150,
   6.1098727269992087e-151,
   3.0549363634996043e-151,
   1.5274681817498022e-151,
   7.6373409087490109e-152,
   3.8186704543745054e-152,
   1.9093352271872527e-152,
   9.5466761359362636e-153,
   4.7733380679681318e-153,
   2.3866690339840659e-153,
   1.1933345169920329e-153,
   5.9666725849601647e-154,
   2.9833362924800824e-154,
   1.4916681462400412e-154,
   7.4583407312002059e-155,
   3.7291703656001030e-155,
   1.8645851828000515e-155,
   9.3229259140002574e-156,
   4.6614629570001287e-156,
   2.3307314785000643e-156,
   1.1653657392500322e-156,
   5.8268286962501609e-157,
   2.9134143481250804e-157,
   1.4567071740625402e-157,
   7.2835358703127011e-158,
   3.6417679351563505e-158,
   1.8208839675781753e-158,
   9.1044198378908764e-159,
   4.5522099189454382e-159,
   2.2761049594727191e-159,
   1.1380524797363595e-159,
   5.6902623986817977e-160,
   2.8451311993408989e-160,
   1.4225655996704494e-160,
   7.1128279983522472e-161,
   3.5564139991761236e-161,
   1.7782069995880618e-161,
   8.8910349979403089e-162,
   4.4455174989701545e-162,
   2.2227587494850772e-162,
   1.1113793747425386e-162,
   5.5568968737126931e-163,
   2.7784484368563465e-163,
   1.3892242184281733e-163,
   6.9461210921408664e-164,
   3.4730605460704332e-164,
   1.7365302730352166e-164,
   8.6826513651760830e-165,
   4.3413256825880415e-165,
   2.1706628412940207e-165,
   1.0853314206470104e-165,
   5.4266571032350518e-166,
   2.7133285516175259e-166,
   1.3566642758087630e-166,
   6.7833213790438148e-167,
   3.3916606895219074e-167,
   1.6958303447609537e-167,
   8.4791517238047685e-168,
   4.2395758619023843e-168,
   2.1197879309511921e-168,
   1.0598939654755961e-168,
   5.2994698273779803e-169,
   2.6497349136889902e-169,
   1.3248674568444951e-169,
   6.6243372842224754e-170,
   3.3121686421112377e-170,
   1.6560843210556188e-170,
   8.2804216052780942e-171,
   4.1402108026390471e-171,
   2.0701054013195236e-171,
   1.0350527006597618e-171,
   5.1752635032988089e-172,
   2.5876317516494045e-172,
   1.2938158758247022e-172,
   6.4690793791235111e-173,
   3.2345396895617556e-173,
   1.6172698447808778e-173,
   8.0863492239043889e-174,
   4.0431746119521945e-174,
   2.0215873059760972e-174,
   1.0107936529880486e-174,
   5.0539682649402431e-175,
   2.5269841324701215e-175,
   1.2634920662350608e-175,
   6.3174603311753038e-176,
   3.1587301655876519e-176,
   1.5793650827938260e-176,
   7.8968254139691298e-177,
   3.9484127069845649e-177,
   1.9742063534922825e-177,
   9.8710317674614123e-178,
   4.9355158837307061e-178,
   2.4677579418653531e-178,
   1.2338789709326765e-178,
   6.1693948546633827e-179,
   3.0846974273316913e-179,
   1.5423487136658457e-179,
   7.7117435683292283e-180,
   3.8558717841646142e-180,
   1.9279358920823071e-180,
   9.6396794604115354e-181,
   4.8198397302057677e-181,
   2.4099198651028839e-181,
   1.2049599325514419e-181,
   6.0247996627572096e-182,
   3.0123998313786048e-182,
   1.5061999156893024e-182,
   7.5309995784465120e-183,
   3.7654997892232560e-183,
   1.8827498946116280e-183,
   9.4137494730581400e-184,
   4.7068747365290700e-184,
   2.3534373682645350e-184,
   1.1767186841322675e-184,
   5.8835934206613375e-185,
   2.9417967103306688e-185,
   1.4708983551653344e-185,
   7.3544917758266719e-186,
   3.6772458879133360e-186,
   1.8386229439566680e-186,
   9.1931147197833399e-187,
   4.5965573598916699e-187,
   2.2982786799458350e-187,
   1.1491393399729175e-187,
   5.7456966998645874e-188,
   2.8728483499322937e-188,
   1.4364241749661469e-188,
   7.1821208748307343e-189,
   3.5910604374153671e-189,
   1.7955302187076836e-189,
   8.9776510935384179e-190,
   4.4888255467692089e-190,
   2.2444127733846045e-190,
   1.1222063866923022e-190,
   5.6110319334615112e-191,
   2.8055159667307556e-191,
   1.4027579833653778e-191,
   7.0137899168268889e-192,
   3.5068949584134445e-192,
   1.7534474792067222e-192,
   8.7672373960336112e-193,
   4.3836186980168056e-193,
   2.1918093490084028e-193,
   1.0959046745042014e-193,
   5.4795233725210070e-194,
   2.7397616862605035e-194,
   1.3698808431302517e-194,
   6.8494042156512587e-195,
   3.4247021078256294e-195,
   1.7123510539128147e-195,
   8.5617552695640734e-196,
   4.2808776347820367e-196,
   2.1404388173910184e-196,
   1.0702194086955092e-196,
   5.3510970434775459e-197,
   2.6755485217387729e-197,
   1.3377742608693865e-197,
   6.6888713043469324e-198,
   3.3444356521734662e-198,
   1.6722178260867331e-198,
   8.3610891304336655e-199,
   4.1805445652168327e-199,
   2.0902722826084164e-199,
   1.0451361413042082e-199,
   5.2256807065210409e-200,
   2.6128403532605205e-200,
   1.3064201766302602e-200,
   6.5321008831513011e-201,
   3.2660504415756506e-201,
   1.6330252207878253e-201,
   8.1651261039391264e-202,
   4.0825630519695632e-202,
   2.0412815259847816e-202,
   1.0206407629923908e-202,
   5.1032038149619540e-203,
   2.5516019074809770e-203,
   1.2758009537404885e-203,
   6.3790047687024425e-204,
   3.1895023843512213e-204,
   1.5947511921756106e-204,
   7.9737559608780531e-205,
   3.9868779804390266e-205,
   1.9934389902195133e-205,
   9.9671949510975664e-206,
   4.9835974755487832e-206,
   2.4917987377743916e-206,
   1.2458993688871958e-206,
   6.2294968444359790e-207,
   3.1147484222179895e-207,
   1.5573742111089948e-207,
   7.7868710555449738e-208,
   3.8934355277724869e-208,
   1.9467177638862434e-208,
   9.7335888194312172e-209,
   4.8667944097156086e-209,
   2.4333972048578043e-209,
   1.2166986024289022e-209,
   6.0834930121445108e-210,
   3.0417465060722554e-210,
   1.5208732530361277e-210,
   7.6043662651806384e-211,
   3.8021831325903192e-211,
   1.9010915662951596e-211,
   9.5054578314757981e-212,
   4.7527289157378990e-212,
   2.3763644578689495e-212,
   1.1881822289344748e-212,
   5.9409111446723738e-213,
   2.9704555723361869e-213,
   1.4852277861680934e-213,
   7.4261389308404672e-214,
   3.7130694654202336e-214,
   1.8565347327101168e-214,
   9.2826736635505840e-215,
   4.6413368317752920e-215,
   2.3206684158876460e-215,
   1.1603342079438230e-215,
   5.8016710397191150e-216,
   2.9008355198595575e-216,
   1.4504177599297788e-216,
   7.2520887996488938e-217,
   3.6260443998244469e-217,
   1.8130221999122234e-217,
   9.0651109995611172e-218,
   4.5325554997805586e-218,
   2.2662777498902793e-218,
   1.1331388749451397e-218,
   5.6656943747256983e-219,
   2.8328471873628491e-219,
   1.4164235936814246e-219,
   7.0821179684071228e-220,
   3.5410589842035614e-220,
   1.7705294921017807e-220,
   8.8526474605089035e-221,
   4.4263237302544518e-221,
   2.2131618651272259e-221,
   1.1065809325636129e-221,
   5.5329046628180647e-222,
   2.7664523314090324e-222,
   1.3832261657045162e-222,
   6.9161308285225809e-223,
   3.4580654142612904e-223,
   1.7290327071306452e-223,
   8.6451635356532261e-224,
   4.3225817678266131e-224,
   2.1612908839133065e-224,
   1.0806454419566533e-224,
   5.4032272097832663e-225,
   2.7016136048916332e-225,
   1.3508068024458166e-225,
   6.7540340122290829e-226,
   3.3770170061145415e-226,
   1.6885085030572707e-226,
   8.4425425152863536e-227,
   4.2212712576431768e-227,
   2.1106356288215884e-227,
   1.0553178144107942e-227,
   5.2765890720539710e-228,
   2.6382945360269855e-228,
   1.3191472680134928e-228,
   6.5957363400674638e-229,
   3.2978681700337319e-229,
   1.6489340850168659e-229,
   8.2446704250843297e-230,
   4.1223352125421649e-230,
   2.0611676062710824e-230,
   1.0305838031355412e-230,
   5.1529190156777061e-231,
   2.5764595078388530e-231,
   1.2882297539194265e-231,
   6.4411487695971326e-232,
   3.2205743847985663e-232,
   1.6102871923992831e-232,
   8.0514359619964157e-233,
   4.0257179809982079e-233,
   2.0128589904991039e-233,
   1.0064294952495520e-233,
   5.0321474762477598e-234,
   2.5160737381238799e-234,
   1.2580368690619400e-234,
   6.2901843453096998e-235,
   3.1450921726548499e-235,
   1.5725460863274249e-235,
   7.8627304316371247e-236,
   3.9313652158185624e-236,
   1.9656826079092812e-236,
   9.8284130395464059e-237,
   4.9142065197732030e-237,
   2.4571032598866015e-237,
   1.2285516299433007e-237,
   6.1427581497165037e-238,
   3.0713790748582519e-238,
   1.5356895374291259e-238,
   7.6784476871456296e-239,
   3.8392238435728148e-239,
   1.9196119217864074e-239,
   9.5980596089320370e-240,
   4.7990298044660185e-240,
   2.3995149022330093e-240,
   1.1997574511165046e-240,
   5.9987872555825232e-241,
   2.9993936277912616e-241,
   1.4996968138956308e-241,
   7.4984840694781539e-242,
   3.7492420347390770e-242,
   1.8746210173695385e-242,
   9.3731050868476924e-243,
   4.6865525434238462e-243,
   2.3432762717119231e-243,
   1.1716381358559616e-243,
   5.8581906792798078e-244,
   2.9290953396399039e-244,
   1.4645476698199519e-244,
   7.3227383490997597e-245,
   3.6613691745498799e-245,
   1.8306845872749399e-245,
   9.1534229363746996e-246,
   4.5767114681873498e-246,
   2.2883557340936749e-246,
   1.1441778670468375e-246,
   5.7208893352341873e-247,
   2.8604446676170936e-247,
   1.4302223338085468e-247,
   7.1511116690427341e-248,
   3.5755558345213670e-248,
   1.7877779172606835e-248,
   8.9388895863034176e-249,
   4.4694447931517088e-249,
   2.2347223965758544e-249,
   1.1173611982879272e-249,
   5.5868059914396360e-250,
   2.7934029957198180e-250,
   1.3967014978599090e-250,
   6.9835074892995450e-251,
   3.4917537446497725e-251,
   1.7458768723248863e-251,
   8.7293843616244313e-252,
   4.3646921808122156e-252,
   2.1823460904061078e-252,
   1.0911730452030539e-252,
   5.4558652260152695e-253,
   2.7279326130076348e-253,
   1.3639663065038174e-253,
   6.8198315325190869e-254,
   3.4099157662595435e-254,
   1.7049578831297717e-254,
   8.5247894156488587e-255,
   4.2623947078244293e-255,
   2.1311973539122147e-255,
   1.0655986769561073e-255,
   5.3279933847805367e-256,
   2.6639966923902683e-256,
   1.3319983461951342e-256,
   6.6599917309756708e-257,
   3.3299958654878354e-257,
   1.6649979327439177e-257,
   8.3249896637195885e-258,
   4.1624948318597943e-258,
   2.0812474159298971e-258,
   1.0406237079649486e-258,
   5.2031185398247428e-259,
   2.6015592699123714e-259,
   1.3007796349561857e-259,
   6.5038981747809285e-260,
   3.2519490873904643e-260,
   1.6259745436952321e-260,
   8.1298727184761607e-261,
   4.0649363592380803e-261,
   2.0324681796190402e-261,
   1.0162340898095201e-261,
   5.0811704490476004e-262,
   2.5405852245238002e-262,
   1.2702926122619001e-262,
   6.3514630613095005e-263,
   3.1757315306547503e-263,
   1.5878657653273751e-263,
   7.9393288266368757e-264,
   3.9696644133184378e-264,
   1.9848322066592189e-264,
   9.9241610332960946e-265,
   4.9620805166480473e-265,
   2.4810402583240236e-265,
   1.2405201291620118e-265,
   6.2026006458100591e-266,
   3.1013003229050296e-266,
   1.5506501614525148e-266,
   7.7532508072625739e-267,
   3.8766254036312869e-267,
   1.9383127018156435e-267,
   9.6915635090782174e-268,
   4.8457817545391087e-268,
   2.4228908772695543e-268,
   1.2114454386347772e-268,
   6.0572271931738858e-269,
   3.0286135965869429e-269,
   1.5143067982934715e-269,
   7.5715339914673573e-270,
   3.7857669957336787e-270,
   1.8928834978668393e-270,
   9.4644174893341966e-271,
   4.7322087446670983e-271,
   2.3661043723335492e-271,
   1.1830521861667746e-271,
   5.9152609308338729e-272,
   2.9576304654169364e-272,
   1.4788152327084682e-272,
   7.3940761635423411e-273,
   3.6970380817711706e-273,
   1.8485190408855853e-273,
   9.2425952044279264e-274,
   4.6212976022139632e-274,
   2.3106488011069816e-274,
   1.1553244005534908e-274,
   5.7766220027674540e-275,
   2.8883110013837270e-275,
   1.4441555006918635e-275,
   7.2207775034593175e-276,
   3.6103887517296588e-276,
   1.8051943758648294e-276,
   9.0259718793241469e-277,
   4.5129859396620734e-277,
   2.2564929698310367e-277,
   1.1282464849155184e-277,
   5.6412324245775918e-278,
   2.8206162122887959e-278,
   1.4103081061443979e-278,
   7.0515405307219897e-279,
   3.5257702653609949e-279,
   1.7628851326804974e-279,
   8.8144256634024872e-280,
   4.4072128317012436e-280,
   2.2036064158506218e-280,
   1.1018032079253109e-280,
   5.5090160396265545e-281,
   2.7545080198132772e-281,
   1.3772540099066386e-281,
   6.8862700495331931e-282,
   3.4431350247665966e-282,
   1.7215675123832983e-282,
   8.6078375619164914e-283,
   4.3039187809582457e-283,
   2.1519593904791228e-283,
   1.0759796952395614e-283,
   5.3798984761978071e-284,
   2.6899492380989036e-284,
   1.3449746190494518e-284,
   6.7248730952472589e-285,
   3.3624365476236295e-285,
   1.6812182738118147e-285,
   8.4060913690590736e-286,
   4.2030456845295368e-286,
   2.1015228422647684e-286,
   1.0507614211323842e-286,
   5.2538071056619210e-287,
   2.6269035528309605e-287,
   1.3134517764154803e-287,
   6.5672588820774013e-288,
   3.2836294410387006e-288,
   1.6418147205193503e-288,
   8.2090736025967516e-289,
   4.1045368012983758e-289,
   2.0522684006491879e-289,
   1.0261342003245939e-289,
   5.1306710016229697e-290,
   2.5653355008114849e-290,
   1.2826677504057424e-290,
   6.4133387520287122e-291,
   3.2066693760143561e-291,
   1.6033346880071780e-291,
   8.0166734400358902e-292,
   4.0083367200179451e-292,
   2.0041683600089726e-292,
   0.0
};

static const double Tick2ToInf[1022] {
   /* GENERATED WITH:
      double high = 2.0;
      high *= 2.0; // first one goes in the variable
      do {
         printf("   %.16le,\n", nextafter(high, 0.0));
         high *= 2.0;
      } while(!isinf(high * 2.0));
      printf("   %.16le\n", 1.7976931348623157e+308); // DBL_MAX
   */
   3.9999999999999996e+00,
   7.9999999999999991e+00,
   1.5999999999999998e+01,
   3.1999999999999996e+01,
   6.3999999999999993e+01,
   1.2799999999999999e+02,
   2.5599999999999997e+02,
   5.1199999999999994e+02,
   1.0239999999999999e+03,
   2.0479999999999998e+03,
   4.0959999999999995e+03,
   8.1919999999999991e+03,
   1.6383999999999998e+04,
   3.2767999999999996e+04,
   6.5535999999999993e+04,
   1.3107199999999999e+05,
   2.6214399999999997e+05,
   5.2428799999999994e+05,
   1.0485759999999999e+06,
   2.0971519999999998e+06,
   4.1943039999999995e+06,
   8.3886079999999991e+06,
   1.6777215999999998e+07,
   3.3554431999999996e+07,
   6.7108863999999993e+07,
   1.3421772799999999e+08,
   2.6843545599999997e+08,
   5.3687091199999994e+08,
   1.0737418239999999e+09,
   2.1474836479999998e+09,
   4.2949672959999995e+09,
   8.5899345919999990e+09,
   1.7179869183999998e+10,
   3.4359738367999996e+10,
   6.8719476735999992e+10,
   1.3743895347199998e+11,
   2.7487790694399997e+11,
   5.4975581388799994e+11,
   1.0995116277759999e+12,
   2.1990232555519998e+12,
   4.3980465111039995e+12,
   8.7960930222079990e+12,
   1.7592186044415998e+13,
   3.5184372088831996e+13,
   7.0368744177663992e+13,
   1.4073748835532798e+14,
   2.8147497671065597e+14,
   5.6294995342131194e+14,
   1.1258999068426239e+15,
   2.2517998136852478e+15,
   4.5035996273704955e+15,
   9.0071992547409910e+15,
   1.8014398509481982e+16,
   3.6028797018963964e+16,
   7.2057594037927928e+16,
   1.4411518807585586e+17,
   2.8823037615171171e+17,
   5.7646075230342342e+17,
   1.1529215046068468e+18,
   2.3058430092136937e+18,
   4.6116860184273874e+18,
   9.2233720368547748e+18,
   1.8446744073709550e+19,
   3.6893488147419099e+19,
   7.3786976294838198e+19,
   1.4757395258967640e+20,
   2.9514790517935279e+20,
   5.9029581035870559e+20,
   1.1805916207174112e+21,
   2.3611832414348223e+21,
   4.7223664828696447e+21,
   9.4447329657392894e+21,
   1.8889465931478579e+22,
   3.7778931862957158e+22,
   7.5557863725914315e+22,
   1.5111572745182863e+23,
   3.0223145490365726e+23,
   6.0446290980731452e+23,
   1.2089258196146290e+24,
   2.4178516392292581e+24,
   4.8357032784585162e+24,
   9.6714065569170323e+24,
   1.9342813113834065e+25,
   3.8685626227668129e+25,
   7.7371252455336259e+25,
   1.5474250491067252e+26,
   3.0948500982134503e+26,
   6.1897001964269007e+26,
   1.2379400392853801e+27,
   2.4758800785707603e+27,
   4.9517601571415205e+27,
   9.9035203142830411e+27,
   1.9807040628566082e+28,
   3.9614081257132164e+28,
   7.9228162514264329e+28,
   1.5845632502852866e+29,
   3.1691265005705732e+29,
   6.3382530011411463e+29,
   1.2676506002282293e+30,
   2.5353012004564585e+30,
   5.0706024009129170e+30,
   1.0141204801825834e+31,
   2.0282409603651668e+31,
   4.0564819207303336e+31,
   8.1129638414606673e+31,
   1.6225927682921335e+32,
   3.2451855365842669e+32,
   6.4903710731685338e+32,
   1.2980742146337068e+33,
   2.5961484292674135e+33,
   5.1922968585348271e+33,
   1.0384593717069654e+34,
   2.0769187434139308e+34,
   4.1538374868278616e+34,
   8.3076749736557233e+34,
   1.6615349947311447e+35,
   3.3230699894622893e+35,
   6.6461399789245786e+35,
   1.3292279957849157e+36,
   2.6584559915698315e+36,
   5.3169119831396629e+36,
   1.0633823966279326e+37,
   2.1267647932558652e+37,
   4.2535295865117303e+37,
   8.5070591730234606e+37,
   1.7014118346046921e+38,
   3.4028236692093843e+38,
   6.8056473384187685e+38,
   1.3611294676837537e+39,
   2.7222589353675074e+39,
   5.4445178707350148e+39,
   1.0889035741470030e+40,
   2.1778071482940059e+40,
   4.3556142965880118e+40,
   8.7112285931760237e+40,
   1.7422457186352047e+41,
   3.4844914372704095e+41,
   6.9689828745408190e+41,
   1.3937965749081638e+42,
   2.7875931498163276e+42,
   5.5751862996326552e+42,
   1.1150372599265310e+43,
   2.2300745198530621e+43,
   4.4601490397061241e+43,
   8.9202980794122483e+43,
   1.7840596158824497e+44,
   3.5681192317648993e+44,
   7.1362384635297986e+44,
   1.4272476927059597e+45,
   2.8544953854119194e+45,
   5.7089907708238389e+45,
   1.1417981541647678e+46,
   2.2835963083295356e+46,
   4.5671926166590711e+46,
   9.1343852333181422e+46,
   1.8268770466636284e+47,
   3.6537540933272569e+47,
   7.3075081866545138e+47,
   1.4615016373309028e+48,
   2.9230032746618055e+48,
   5.8460065493236110e+48,
   1.1692013098647222e+49,
   2.3384026197294444e+49,
   4.6768052394588888e+49,
   9.3536104789177776e+49,
   1.8707220957835555e+50,
   3.7414441915671111e+50,
   7.4828883831342221e+50,
   1.4965776766268444e+51,
   2.9931553532536888e+51,
   5.9863107065073777e+51,
   1.1972621413014755e+52,
   2.3945242826029511e+52,
   4.7890485652059022e+52,
   9.5780971304118043e+52,
   1.9156194260823609e+53,
   3.8312388521647217e+53,
   7.6624777043294434e+53,
   1.5324955408658887e+54,
   3.0649910817317774e+54,
   6.1299821634635548e+54,
   1.2259964326927110e+55,
   2.4519928653854219e+55,
   4.9039857307708438e+55,
   9.8079714615416876e+55,
   1.9615942923083375e+56,
   3.9231885846166750e+56,
   7.8463771692333501e+56,
   1.5692754338466700e+57,
   3.1385508676933400e+57,
   6.2771017353866801e+57,
   1.2554203470773360e+58,
   2.5108406941546720e+58,
   5.0216813883093441e+58,
   1.0043362776618688e+59,
   2.0086725553237376e+59,
   4.0173451106474752e+59,
   8.0346902212949505e+59,
   1.6069380442589901e+60,
   3.2138760885179802e+60,
   6.4277521770359604e+60,
   1.2855504354071921e+61,
   2.5711008708143842e+61,
   5.1422017416287683e+61,
   1.0284403483257537e+62,
   2.0568806966515073e+62,
   4.1137613933030146e+62,
   8.2275227866060293e+62,
   1.6455045573212059e+63,
   3.2910091146424117e+63,
   6.5820182292848234e+63,
   1.3164036458569647e+64,
   2.6328072917139294e+64,
   5.2656145834278588e+64,
   1.0531229166855718e+65,
   2.1062458333711435e+65,
   4.2124916667422870e+65,
   8.4249833334845740e+65,
   1.6849966666969148e+66,
   3.3699933333938296e+66,
   6.7399866667876592e+66,
   1.3479973333575318e+67,
   2.6959946667150637e+67,
   5.3919893334301274e+67,
   1.0783978666860255e+68,
   2.1567957333720509e+68,
   4.3135914667441019e+68,
   8.6271829334882038e+68,
   1.7254365866976408e+69,
   3.4508731733952815e+69,
   6.9017463467905630e+69,
   1.3803492693581126e+70,
   2.7606985387162252e+70,
   5.5213970774324504e+70,
   1.1042794154864901e+71,
   2.2085588309729802e+71,
   4.4171176619459603e+71,
   8.8342353238919207e+71,
   1.7668470647783841e+72,
   3.5336941295567683e+72,
   7.0673882591135365e+72,
   1.4134776518227073e+73,
   2.8269553036454146e+73,
   5.6539106072908292e+73,
   1.1307821214581658e+74,
   2.2615642429163317e+74,
   4.5231284858326634e+74,
   9.0462569716653268e+74,
   1.8092513943330654e+75,
   3.6185027886661307e+75,
   7.2370055773322614e+75,
   1.4474011154664523e+76,
   2.8948022309329046e+76,
   5.7896044618658091e+76,
   1.1579208923731618e+77,
   2.3158417847463237e+77,
   4.6316835694926473e+77,
   9.2633671389852946e+77,
   1.8526734277970589e+78,
   3.7053468555941178e+78,
   7.4106937111882357e+78,
   1.4821387422376471e+79,
   2.9642774844752943e+79,
   5.9285549689505885e+79,
   1.1857109937901177e+80,
   2.3714219875802354e+80,
   4.7428439751604708e+80,
   9.4856879503209417e+80,
   1.8971375900641883e+81,
   3.7942751801283767e+81,
   7.5885503602567533e+81,
   1.5177100720513507e+82,
   3.0354201441027013e+82,
   6.0708402882054027e+82,
   1.2141680576410805e+83,
   2.4283361152821611e+83,
   4.8566722305643221e+83,
   9.7133444611286443e+83,
   1.9426688922257289e+84,
   3.8853377844514577e+84,
   7.7706755689029154e+84,
   1.5541351137805831e+85,
   3.1082702275611662e+85,
   6.2165404551223323e+85,
   1.2433080910244665e+86,
   2.4866161820489329e+86,
   4.9732323640978659e+86,
   9.9464647281957317e+86,
   1.9892929456391463e+87,
   3.9785858912782927e+87,
   7.9571717825565854e+87,
   1.5914343565113171e+88,
   3.1828687130226342e+88,
   6.3657374260452683e+88,
   1.2731474852090537e+89,
   2.5462949704181073e+89,
   5.0925899408362147e+89,
   1.0185179881672429e+90,
   2.0370359763344859e+90,
   4.0740719526689717e+90,
   8.1481439053379434e+90,
   1.6296287810675887e+91,
   3.2592575621351774e+91,
   6.5185151242703548e+91,
   1.3037030248540710e+92,
   2.6074060497081419e+92,
   5.2148120994162838e+92,
   1.0429624198832568e+93,
   2.0859248397665135e+93,
   4.1718496795330270e+93,
   8.3436993590660541e+93,
   1.6687398718132108e+94,
   3.3374797436264216e+94,
   6.6749594872528433e+94,
   1.3349918974505687e+95,
   2.6699837949011373e+95,
   5.3399675898022746e+95,
   1.0679935179604549e+96,
   2.1359870359209098e+96,
   4.2719740718418197e+96,
   8.5439481436836394e+96,
   1.7087896287367279e+97,
   3.4175792574734558e+97,
   6.8351585149469115e+97,
   1.3670317029893823e+98,
   2.7340634059787646e+98,
   5.4681268119575292e+98,
   1.0936253623915058e+99,
   2.1872507247830117e+99,
   4.3745014495660234e+99,
   8.7490028991320467e+99,
   1.7498005798264093e+100,
   3.4996011596528187e+100,
   6.9992023193056374e+100,
   1.3998404638611275e+101,
   2.7996809277222550e+101,
   5.5993618554445099e+101,
   1.1198723710889020e+102,
   2.2397447421778040e+102,
   4.4794894843556079e+102,
   8.9589789687112158e+102,
   1.7917957937422432e+103,
   3.5835915874844863e+103,
   7.1671831749689727e+103,
   1.4334366349937945e+104,
   2.8668732699875891e+104,
   5.7337465399751781e+104,
   1.1467493079950356e+105,
   2.2934986159900713e+105,
   4.5869972319801425e+105,
   9.1739944639602850e+105,
   1.8347988927920570e+106,
   3.6695977855841140e+106,
   7.3391955711682280e+106,
   1.4678391142336456e+107,
   2.9356782284672912e+107,
   5.8713564569345824e+107,
   1.1742712913869165e+108,
   2.3485425827738330e+108,
   4.6970851655476659e+108,
   9.3941703310953319e+108,
   1.8788340662190664e+109,
   3.7576681324381327e+109,
   7.5153362648762655e+109,
   1.5030672529752531e+110,
   3.0061345059505062e+110,
   6.0122690119010124e+110,
   1.2024538023802025e+111,
   2.4049076047604050e+111,
   4.8098152095208099e+111,
   9.6196304190416198e+111,
   1.9239260838083240e+112,
   3.8478521676166479e+112,
   7.6957043352332959e+112,
   1.5391408670466592e+113,
   3.0782817340933183e+113,
   6.1565634681866367e+113,
   1.2313126936373273e+114,
   2.4626253872746547e+114,
   4.9252507745493094e+114,
   9.8505015490986187e+114,
   1.9701003098197237e+115,
   3.9402006196394475e+115,
   7.8804012392788950e+115,
   1.5760802478557790e+116,
   3.1521604957115580e+116,
   6.3043209914231160e+116,
   1.2608641982846232e+117,
   2.5217283965692464e+117,
   5.0434567931384928e+117,
   1.0086913586276986e+118,
   2.0173827172553971e+118,
   4.0347654345107942e+118,
   8.0695308690215884e+118,
   1.6139061738043177e+119,
   3.2278123476086354e+119,
   6.4556246952172708e+119,
   1.2911249390434542e+120,
   2.5822498780869083e+120,
   5.1644997561738166e+120,
   1.0328999512347633e+121,
   2.0657999024695266e+121,
   4.1315998049390533e+121,
   8.2631996098781066e+121,
   1.6526399219756213e+122,
   3.3052798439512426e+122,
   6.6105596879024853e+122,
   1.3221119375804971e+123,
   2.6442238751609941e+123,
   5.2884477503219882e+123,
   1.0576895500643976e+124,
   2.1153791001287953e+124,
   4.2307582002575906e+124,
   8.4615164005151811e+124,
   1.6923032801030362e+125,
   3.3846065602060725e+125,
   6.7692131204121449e+125,
   1.3538426240824290e+126,
   2.7076852481648580e+126,
   5.4153704963297159e+126,
   1.0830740992659432e+127,
   2.1661481985318864e+127,
   4.3322963970637727e+127,
   8.6645927941275455e+127,
   1.7329185588255091e+128,
   3.4658371176510182e+128,
   6.9316742353020364e+128,
   1.3863348470604073e+129,
   2.7726696941208146e+129,
   5.5453393882416291e+129,
   1.1090678776483258e+130,
   2.2181357552966516e+130,
   4.4362715105933033e+130,
   8.8725430211866066e+130,
   1.7745086042373213e+131,
   3.5490172084746426e+131,
   7.0980344169492853e+131,
   1.4196068833898571e+132,
   2.8392137667797141e+132,
   5.6784275335594282e+132,
   1.1356855067118856e+133,
   2.2713710134237713e+133,
   4.5427420268475426e+133,
   9.0854840536950851e+133,
   1.8170968107390170e+134,
   3.6341936214780340e+134,
   7.2683872429560681e+134,
   1.4536774485912136e+135,
   2.9073548971824272e+135,
   5.8147097943648545e+135,
   1.1629419588729709e+136,
   2.3258839177459418e+136,
   4.6517678354918836e+136,
   9.3035356709837672e+136,
   1.8607071341967534e+137,
   3.7214142683935069e+137,
   7.4428285367870137e+137,
   1.4885657073574027e+138,
   2.9771314147148055e+138,
   5.9542628294296110e+138,
   1.1908525658859222e+139,
   2.3817051317718444e+139,
   4.7634102635436888e+139,
   9.5268205270873776e+139,
   1.9053641054174755e+140,
   3.8107282108349510e+140,
   7.6214564216699021e+140,
   1.5242912843339804e+141,
   3.0485825686679608e+141,
   6.0971651373359216e+141,
   1.2194330274671843e+142,
   2.4388660549343687e+142,
   4.8777321098687373e+142,
   9.7554642197374746e+142,
   1.9510928439474949e+143,
   3.9021856878949899e+143,
   7.8043713757899797e+143,
   1.5608742751579959e+144,
   3.1217485503159919e+144,
   6.2434971006319838e+144,
   1.2486994201263968e+145,
   2.4973988402527935e+145,
   4.9947976805055870e+145,
   9.9895953610111740e+145,
   1.9979190722022348e+146,
   3.9958381444044696e+146,
   7.9916762888089392e+146,
   1.5983352577617878e+147,
   3.1966705155235757e+147,
   6.3933410310471514e+147,
   1.2786682062094303e+148,
   2.5573364124188606e+148,
   5.1146728248377211e+148,
   1.0229345649675442e+149,
   2.0458691299350884e+149,
   4.0917382598701769e+149,
   8.1834765197403538e+149,
   1.6366953039480708e+150,
   3.2733906078961415e+150,
   6.5467812157922830e+150,
   1.3093562431584566e+151,
   2.6187124863169132e+151,
   5.2374249726338264e+151,
   1.0474849945267653e+152,
   2.0949699890535306e+152,
   4.1899399781070611e+152,
   8.3798799562141223e+152,
   1.6759759912428245e+153,
   3.3519519824856489e+153,
   6.7039039649712978e+153,
   1.3407807929942596e+154,
   2.6815615859885191e+154,
   5.3631231719770382e+154,
   1.0726246343954076e+155,
   2.1452492687908153e+155,
   4.2904985375816306e+155,
   8.5809970751632612e+155,
   1.7161994150326522e+156,
   3.4323988300653045e+156,
   6.8647976601306090e+156,
   1.3729595320261218e+157,
   2.7459190640522436e+157,
   5.4918381281044872e+157,
   1.0983676256208974e+158,
   2.1967352512417949e+158,
   4.3934705024835897e+158,
   8.7869410049671795e+158,
   1.7573882009934359e+159,
   3.5147764019868718e+159,
   7.0295528039737436e+159,
   1.4059105607947487e+160,
   2.8118211215894974e+160,
   5.6236422431789949e+160,
   1.1247284486357990e+161,
   2.2494568972715979e+161,
   4.4989137945431959e+161,
   8.9978275890863918e+161,
   1.7995655178172784e+162,
   3.5991310356345567e+162,
   7.1982620712691134e+162,
   1.4396524142538227e+163,
   2.8793048285076454e+163,
   5.7586096570152907e+163,
   1.1517219314030581e+164,
   2.3034438628061163e+164,
   4.6068877256122326e+164,
   9.2137754512244652e+164,
   1.8427550902448930e+165,
   3.6855101804897861e+165,
   7.3710203609795721e+165,
   1.4742040721959144e+166,
   2.9484081443918289e+166,
   5.8968162887836577e+166,
   1.1793632577567315e+167,
   2.3587265155134631e+167,
   4.7174530310269262e+167,
   9.4349060620538523e+167,
   1.8869812124107705e+168,
   3.7739624248215409e+168,
   7.5479248496430819e+168,
   1.5095849699286164e+169,
   3.0191699398572327e+169,
   6.0383398797144655e+169,
   1.2076679759428931e+170,
   2.4153359518857862e+170,
   4.8306719037715724e+170,
   9.6613438075431448e+170,
   1.9322687615086290e+171,
   3.8645375230172579e+171,
   7.7290750460345158e+171,
   1.5458150092069032e+172,
   3.0916300184138063e+172,
   6.1832600368276127e+172,
   1.2366520073655225e+173,
   2.4733040147310451e+173,
   4.9466080294620901e+173,
   9.8932160589241803e+173,
   1.9786432117848361e+174,
   3.9572864235696721e+174,
   7.9145728471393442e+174,
   1.5829145694278688e+175,
   3.1658291388557377e+175,
   6.3316582777114754e+175,
   1.2663316555422951e+176,
   2.5326633110845901e+176,
   5.0653266221691803e+176,
   1.0130653244338361e+177,
   2.0261306488676721e+177,
   4.0522612977353442e+177,
   8.1045225954706885e+177,
   1.6209045190941377e+178,
   3.2418090381882754e+178,
   6.4836180763765508e+178,
   1.2967236152753102e+179,
   2.5934472305506203e+179,
   5.1868944611012406e+179,
   1.0373788922202481e+180,
   2.0747577844404962e+180,
   4.1495155688809925e+180,
   8.2990311377619850e+180,
   1.6598062275523970e+181,
   3.3196124551047940e+181,
   6.6392249102095880e+181,
   1.3278449820419176e+182,
   2.6556899640838352e+182,
   5.3113799281676704e+182,
   1.0622759856335341e+183,
   2.1245519712670682e+183,
   4.2491039425341363e+183,
   8.4982078850682726e+183,
   1.6996415770136545e+184,
   3.3992831540273091e+184,
   6.7985663080546181e+184,
   1.3597132616109236e+185,
   2.7194265232218472e+185,
   5.4388530464436945e+185,
   1.0877706092887389e+186,
   2.1755412185774778e+186,
   4.3510824371549556e+186,
   8.7021648743099112e+186,
   1.7404329748619822e+187,
   3.4808659497239645e+187,
   6.9617318994479289e+187,
   1.3923463798895858e+188,
   2.7846927597791716e+188,
   5.5693855195583432e+188,
   1.1138771039116686e+189,
   2.2277542078233373e+189,
   4.4555084156466745e+189,
   8.9110168312933490e+189,
   1.7822033662586698e+190,
   3.5644067325173396e+190,
   7.1288134650346792e+190,
   1.4257626930069358e+191,
   2.8515253860138717e+191,
   5.7030507720277434e+191,
   1.1406101544055487e+192,
   2.2812203088110974e+192,
   4.5624406176221947e+192,
   9.1248812352443894e+192,
   1.8249762470488779e+193,
   3.6499524940977558e+193,
   7.2999049881955115e+193,
   1.4599809976391023e+194,
   2.9199619952782046e+194,
   5.8399239905564092e+194,
   1.1679847981112818e+195,
   2.3359695962225637e+195,
   4.6719391924451274e+195,
   9.3438783848902548e+195,
   1.8687756769780510e+196,
   3.7375513539561019e+196,
   7.4751027079122038e+196,
   1.4950205415824408e+197,
   2.9900410831648815e+197,
   5.9800821663297631e+197,
   1.1960164332659526e+198,
   2.3920328665319052e+198,
   4.7840657330638104e+198,
   9.5681314661276209e+198,
   1.9136262932255242e+199,
   3.8272525864510484e+199,
   7.6545051729020967e+199,
   1.5309010345804193e+200,
   3.0618020691608387e+200,
   6.1236041383216774e+200,
   1.2247208276643355e+201,
   2.4494416553286709e+201,
   4.8988833106573419e+201,
   9.7977666213146838e+201,
   1.9595533242629368e+202,
   3.9191066485258735e+202,
   7.8382132970517470e+202,
   1.5676426594103494e+203,
   3.1352853188206988e+203,
   6.2705706376413976e+203,
   1.2541141275282795e+204,
   2.5082282550565590e+204,
   5.0164565101131181e+204,
   1.0032913020226236e+205,
   2.0065826040452472e+205,
   4.0131652080904945e+205,
   8.0263304161809890e+205,
   1.6052660832361978e+206,
   3.2105321664723956e+206,
   6.4210643329447912e+206,
   1.2842128665889582e+207,
   2.5684257331779165e+207,
   5.1368514663558329e+207,
   1.0273702932711666e+208,
   2.0547405865423332e+208,
   4.1094811730846663e+208,
   8.2189623461693327e+208,
   1.6437924692338665e+209,
   3.2875849384677331e+209,
   6.5751698769354662e+209,
   1.3150339753870932e+210,
   2.6300679507741865e+210,
   5.2601359015483729e+210,
   1.0520271803096746e+211,
   2.1040543606193492e+211,
   4.2081087212386983e+211,
   8.4162174424773967e+211,
   1.6832434884954793e+212,
   3.3664869769909587e+212,
   6.7329739539819173e+212,
   1.3465947907963835e+213,
   2.6931895815927669e+213,
   5.3863791631855339e+213,
   1.0772758326371068e+214,
   2.1545516652742135e+214,
   4.3091033305484271e+214,
   8.6182066610968542e+214,
   1.7236413322193708e+215,
   3.4472826644387417e+215,
   6.8945653288774834e+215,
   1.3789130657754967e+216,
   2.7578261315509933e+216,
   5.5156522631019867e+216,
   1.1031304526203973e+217,
   2.2062609052407947e+217,
   4.4125218104815893e+217,
   8.8250436209631787e+217,
   1.7650087241926357e+218,
   3.5300174483852715e+218,
   7.0600348967705430e+218,
   1.4120069793541086e+219,
   2.8240139587082172e+219,
   5.6480279174164344e+219,
   1.1296055834832869e+220,
   2.2592111669665737e+220,
   4.5184223339331475e+220,
   9.0368446678662950e+220,
   1.8073689335732590e+221,
   3.6147378671465180e+221,
   7.2294757342930360e+221,
   1.4458951468586072e+222,
   2.8917902937172144e+222,
   5.7835805874344288e+222,
   1.1567161174868858e+223,
   2.3134322349737715e+223,
   4.6268644699475430e+223,
   9.2537289398950861e+223,
   1.8507457879790172e+224,
   3.7014915759580344e+224,
   7.4029831519160689e+224,
   1.4805966303832138e+225,
   2.9611932607664275e+225,
   5.9223865215328551e+225,
   1.1844773043065710e+226,
   2.3689546086131420e+226,
   4.7379092172262841e+226,
   9.4758184344525681e+226,
   1.8951636868905136e+227,
   3.7903273737810273e+227,
   7.5806547475620545e+227,
   1.5161309495124109e+228,
   3.0322618990248218e+228,
   6.0645237980496436e+228,
   1.2129047596099287e+229,
   2.4258095192198574e+229,
   4.8516190384397149e+229,
   9.7032380768794298e+229,
   1.9406476153758860e+230,
   3.8812952307517719e+230,
   7.7625904615035438e+230,
   1.5525180923007088e+231,
   3.1050361846014175e+231,
   6.2100723692028351e+231,
   1.2420144738405670e+232,
   2.4840289476811340e+232,
   4.9680578953622680e+232,
   9.9361157907245361e+232,
   1.9872231581449072e+233,
   3.9744463162898144e+233,
   7.9488926325796289e+233,
   1.5897785265159258e+234,
   3.1795570530318515e+234,
   6.3591141060637031e+234,
   1.2718228212127406e+235,
   2.5436456424254812e+235,
   5.0872912848509625e+235,
   1.0174582569701925e+236,
   2.0349165139403850e+236,
   4.0698330278807700e+236,
   8.1396660557615400e+236,
   1.6279332111523080e+237,
   3.2558664223046160e+237,
   6.5117328446092320e+237,
   1.3023465689218464e+238,
   2.6046931378436928e+238,
   5.2093862756873856e+238,
   1.0418772551374771e+239,
   2.0837545102749542e+239,
   4.1675090205499085e+239,
   8.3350180410998169e+239,
   1.6670036082199634e+240,
   3.3340072164399268e+240,
   6.6680144328798535e+240,
   1.3336028865759707e+241,
   2.6672057731519414e+241,
   5.3344115463038828e+241,
   1.0668823092607766e+242,
   2.1337646185215531e+242,
   4.2675292370431063e+242,
   8.5350584740862125e+242,
   1.7070116948172425e+243,
   3.4140233896344850e+243,
   6.8280467792689700e+243,
   1.3656093558537940e+244,
   2.7312187117075880e+244,
   5.4624374234151760e+244,
   1.0924874846830352e+245,
   2.1849749693660704e+245,
   4.3699499387321408e+245,
   8.7398998774642816e+245,
   1.7479799754928563e+246,
   3.4959599509857126e+246,
   6.9919199019714253e+246,
   1.3983839803942851e+247,
   2.7967679607885701e+247,
   5.5935359215771402e+247,
   1.1187071843154280e+248,
   2.2374143686308561e+248,
   4.4748287372617122e+248,
   8.9496574745234244e+248,
   1.7899314949046849e+249,
   3.5798629898093698e+249,
   7.1597259796187395e+249,
   1.4319451959237479e+250,
   2.8638903918474958e+250,
   5.7277807836949916e+250,
   1.1455561567389983e+251,
   2.2911123134779966e+251,
   4.5822246269559933e+251,
   9.1644492539119866e+251,
   1.8328898507823973e+252,
   3.6657797015647946e+252,
   7.3315594031295893e+252,
   1.4663118806259179e+253,
   2.9326237612518357e+253,
   5.8652475225036714e+253,
   1.1730495045007343e+254,
   2.3460990090014686e+254,
   4.6921980180029371e+254,
   9.3843960360058742e+254,
   1.8768792072011748e+255,
   3.7537584144023497e+255,
   7.5075168288046994e+255,
   1.5015033657609399e+256,
   3.0030067315218798e+256,
   6.0060134630437595e+256,
   1.2012026926087519e+257,
   2.4024053852175038e+257,
   4.8048107704350076e+257,
   9.6096215408700152e+257,
   1.9219243081740030e+258,
   3.8438486163480061e+258,
   7.6876972326960122e+258,
   1.5375394465392024e+259,
   3.0750788930784049e+259,
   6.1501577861568097e+259,
   1.2300315572313619e+260,
   2.4600631144627239e+260,
   4.9201262289254478e+260,
   9.8402524578508956e+260,
   1.9680504915701791e+261,
   3.9361009831403582e+261,
   7.8722019662807165e+261,
   1.5744403932561433e+262,
   3.1488807865122866e+262,
   6.2977615730245732e+262,
   1.2595523146049146e+263,
   2.5191046292098293e+263,
   5.0382092584196585e+263,
   1.0076418516839317e+264,
   2.0152837033678634e+264,
   4.0305674067357268e+264,
   8.0611348134714537e+264,
   1.6122269626942907e+265,
   3.2244539253885815e+265,
   6.4489078507771629e+265,
   1.2897815701554326e+266,
   2.5795631403108652e+266,
   5.1591262806217303e+266,
   1.0318252561243461e+267,
   2.0636505122486921e+267,
   4.1273010244973843e+267,
   8.2546020489947686e+267,
   1.6509204097989537e+268,
   3.3018408195979074e+268,
   6.6036816391958148e+268,
   1.3207363278391630e+269,
   2.6414726556783259e+269,
   5.2829453113566519e+269,
   1.0565890622713304e+270,
   2.1131781245426608e+270,
   4.2263562490853215e+270,
   8.4527124981706430e+270,
   1.6905424996341286e+271,
   3.3810849992682572e+271,
   6.7621699985365144e+271,
   1.3524339997073029e+272,
   2.7048679994146058e+272,
   5.4097359988292115e+272,
   1.0819471997658423e+273,
   2.1638943995316846e+273,
   4.3277887990633692e+273,
   8.6555775981267384e+273,
   1.7311155196253477e+274,
   3.4622310392506954e+274,
   6.9244620785013907e+274,
   1.3848924157002781e+275,
   2.7697848314005563e+275,
   5.5395696628011126e+275,
   1.1079139325602225e+276,
   2.2158278651204450e+276,
   4.4316557302408901e+276,
   8.8633114604817802e+276,
   1.7726622920963560e+277,
   3.5453245841927121e+277,
   7.0906491683854241e+277,
   1.4181298336770848e+278,
   2.8362596673541697e+278,
   5.6725193347083393e+278,
   1.1345038669416679e+279,
   2.2690077338833357e+279,
   4.5380154677666714e+279,
   9.0760309355333429e+279,
   1.8152061871066686e+280,
   3.6304123742133372e+280,
   7.2608247484266743e+280,
   1.4521649496853349e+281,
   2.9043298993706697e+281,
   5.8086597987413394e+281,
   1.1617319597482679e+282,
   2.3234639194965358e+282,
   4.6469278389930716e+282,
   9.2938556779861431e+282,
   1.8587711355972286e+283,
   3.7175422711944572e+283,
   7.4350845423889145e+283,
   1.4870169084777829e+284,
   2.9740338169555658e+284,
   5.9480676339111316e+284,
   1.1896135267822263e+285,
   2.3792270535644526e+285,
   4.7584541071289053e+285,
   9.5169082142578105e+285,
   1.9033816428515621e+286,
   3.8067632857031242e+286,
   7.6135265714062484e+286,
   1.5227053142812497e+287,
   3.0454106285624994e+287,
   6.0908212571249987e+287,
   1.2181642514249997e+288,
   2.4363285028499995e+288,
   4.8726570056999990e+288,
   9.7453140113999980e+288,
   1.9490628022799996e+289,
   3.8981256045599992e+289,
   7.7962512091199984e+289,
   1.5592502418239997e+290,
   3.1185004836479994e+290,
   6.2370009672959987e+290,
   1.2474001934591997e+291,
   2.4948003869183995e+291,
   4.9896007738367990e+291,
   9.9792015476735980e+291,
   1.9958403095347196e+292,
   3.9916806190694392e+292,
   7.9833612381388784e+292,
   1.5966722476277757e+293,
   3.1933444952555513e+293,
   6.3866889905111027e+293,
   1.2773377981022205e+294,
   2.5546755962044411e+294,
   5.1093511924088822e+294,
   1.0218702384817764e+295,
   2.0437404769635529e+295,
   4.0874809539271057e+295,
   8.1749619078542114e+295,
   1.6349923815708423e+296,
   3.2699847631416846e+296,
   6.5399695262833692e+296,
   1.3079939052566738e+297,
   2.6159878105133477e+297,
   5.2319756210266953e+297,
   1.0463951242053391e+298,
   2.0927902484106781e+298,
   4.1855804968213563e+298,
   8.3711609936427125e+298,
   1.6742321987285425e+299,
   3.3484643974570850e+299,
   6.6969287949141700e+299,
   1.3393857589828340e+300,
   2.6787715179656680e+300,
   5.3575430359313360e+300,
   1.0715086071862672e+301,
   2.1430172143725344e+301,
   4.2860344287450688e+301,
   8.5720688574901376e+301,
   1.7144137714980275e+302,
   3.4288275429960550e+302,
   6.8576550859921101e+302,
   1.3715310171984220e+303,
   2.7430620343968440e+303,
   5.4861240687936881e+303,
   1.0972248137587376e+304,
   2.1944496275174752e+304,
   4.3888992550349505e+304,
   8.7777985100699009e+304,
   1.7555597020139802e+305,
   3.5111194040279604e+305,
   7.0222388080559207e+305,
   1.4044477616111841e+306,
   2.8088955232223683e+306,
   5.6177910464447366e+306,
   1.1235582092889473e+307,
   2.2471164185778946e+307,
   4.4942328371557893e+307,
   1.7976931348623157e+308
};

// General float info: https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
//
// This is a cross-language portable implementation of nextafter that skips over subnormals per EBM spec.
// 
// TickUpInternal and TickDownInternal will return correct and reproducible results even if:
//   - a subnormal input is given. We treat subnormals as equal to zero per the EBM spec
//   - a subnormal is the next tick. We return zero in this case since the EBM spec skips over subnormals
//   - "flush-to-zero" or "denormals-are-zero" ("subnormals-are-zero") is enabled on the CPU
//   - a negative zero input is given, or if negative zeros are disabled in the compiler
//   - any of the allowed IEEE-754 rounding modes are chosen, since we do not round any values in these functions
//   - we do not require that the CPU/compiler have correct rounding since we start from numbers that have
//     exact representations in IEEE-754 and our operations generate new numbers that also have exact representations
//   - if NaN has a valid meaning in the language, then this returns NaN on NaN input
//   - if NaN is not a language supported feature, but values can still be NaN anyways, we handle that
//   - if infinity is supported, it will tick up to infinity and stay there with subsequent forward ticks
//   - if infinity is supported, we can tick backwards to the biggest number from an infinity value
//   - if infinity is not a language supported feature, but values can be infinity anyways, we handle that
//   - if the environment supports extended precision, we force the environment to round the value to its chosen
//     non-extended precision value by passing inputs in via arrays which cannot contain the extra bits
//     In C++ on Intel we also set compiler flags to only use the SSE2 registers which do not have extended 
//     precision, unlike x87
//   - TickUpInternal and TickDownInternal do not make use of multiply and add semantics, so any fused CPU 
//     instructions that use correct rounding on the final result are not used
//
// TickUpInternal and TickDownInternal have limited requirements to work properly.  We require that the numbers have 
// IEEE-754 format, which has been the case for all common CPUs released since the 1980s.  We require that the numbers
// in this file are converted to their exact IEEE-754 representation, which is a requirement by the IEEE-754 standard
// when numbers are provided with 17 digits of precision, which we provide.

constexpr double k_minNonSubnormal = 2.2250738585072014e-308; // DBL_MIN
constexpr double k_minNonSubnormalTickUp = 2.2250738585072019e-308; // nextafter(DBL_MIN, DBL_MAX)
constexpr double k_maxNonInf = 1.7976931348623157e+308; // DBL_MAX
constexpr double k_nonDoubleable = 8.9884656743115795e+307; // if you double this power of two you get +inf
constexpr double k_nonDoubleableTickDown = 8.9884656743115785e+307; // nextafter(k_nonDoubleable, 0.0)
constexpr double k_lastTick = 1.9958403095347198e+292; // the tick for numbers beyond nonDoubleable
constexpr double k_epsilon = 2.2204460492503131e-16; // DBL_EPSILON
constexpr double k_subnormToNorm = 4503599627370496.0;
constexpr double k_normToSubnorm = 2.2204460492503131e-16;

static_assert(k_subnormToNorm == std::numeric_limits<double>::min() / std::numeric_limits<double>::denorm_min(),
   "bad min to denorm_min ratio");
static_assert(k_subnormToNorm * k_normToSubnorm == 1.0, "bad k_normToSubnorm");
static_assert(k_epsilon == DBL_EPSILON, "bad k_epsilon");
static_assert(k_maxNonInf == DBL_MAX, "bad k_maxNonInf");
static_assert(k_minNonSubnormal == DBL_MIN, "bad k_minNonSubnormal");
static_assert(k_nonDoubleable + k_lastTick != k_nonDoubleable, "bad k_lastTick");
static_assert(k_nonDoubleable + k_lastTick / 2 == k_nonDoubleable, "bad k_lastTick");
static_assert(k_nonDoubleable - k_lastTick / 2 != k_nonDoubleable, "bad k_lastTick");
static_assert(k_nonDoubleable * 2 == std::numeric_limits<double>::infinity(), "bad k_nonDoubleable");
static_assert((k_nonDoubleable - k_lastTick / 2) * 2 != std::numeric_limits<double>::infinity(), "bad k_nonDoubleable");
static_assert((k_nonDoubleable - k_lastTick / 2) == k_nonDoubleableTickDown, "bad k_nonDoubleableTickDown");
static_assert(std::numeric_limits<double>::infinity() == k_nonDoubleable * 2, "bad k_nonDoubleable");
static_assert(std::numeric_limits<double>::infinity() != k_nonDoubleableTickDown * 2, "bad k_nonDoubleableTickDown");

extern double TickUpInternal(double deprecisioned[1]) noexcept {
   // This is a cross-language portable implementation of nextafter

   // We pass values in as an array in order to force the elimination of any possible extended precision bits.
   double val = deprecisioned[0];

   if(isnan(val)) {
      // the rest of this function will work if IEEE-754 NaN handling is enabled, but check here for additional safety
      return val;
   }
   if(val < k_minNonSubnormal) {
      if(-k_minNonSubnormalTickUp < val) {
         if(-k_minNonSubnormal < val) {
            return k_minNonSubnormal;
         } else {
            return 0.0;
         }
      }
      if(-1.0 <= val) {
         // We cannot let tick enter the subnormal range since subnormals are spaced differently from normal floats.
         // By shifting upwards through a multiple we can maintain the same spacing for the epsilons
         
         val *= k_subnormToNorm;
         double low = -1.0 * k_subnormToNorm * 0.5;
         double tick = k_epsilon * k_subnormToNorm * 0.5;
         while(low <= val) {
            low *= 0.5;
            tick *= 0.5;
            EBM_ASSERT(DBL_MIN <= tick);
         }
         return (val + tick) * k_normToSubnorm;
      } else {
         if(val < -k_nonDoubleable) {
            // if val is -inf we can't exit the loop below without this check
            if(val < -k_maxNonInf) {
               // if val is -infinity then tick up to the biggest negative number
               return -k_maxNonInf;
            } else {
               // avoid hitting -infinity high by checking for the last doubling
               return val + k_lastTick;
            }
         }
         double high = -2.0;
         double tick = k_epsilon;
         while(val < high) {
            high *= 2.0;
            tick *= 2.0;
            EBM_ASSERT(!isinf(tick));
         }
         return val + tick;
      }
   } else {
      if(val <= 0.99999999999999989 /* nextafter(1.0, 0.0) */) {
         // We cannot let tick enter the subnormal range since subnormals are spaced differently from normal floats.
         // By shifting upwards through a multiple we can maintain the same spacing for the epsilons

         val *= k_subnormToNorm;
         double low = 2.2517998136852478e+15 /* nextafter(1.0 * k_subnormToNorm * 0.5, 0.0) */;
         double tick = k_epsilon * k_subnormToNorm * 0.5;
         size_t iBoundary = 0;
         while(val <= low) {
            EBM_ASSERT(iBoundary < sizeof(Tick1To0) / sizeof(Tick1To0[0]));
            // we use this array with tick downs from powers of two in case this function is ported without using
            // an array to pass in the values.  If this happens, the extended precision bits can be between the power
            // of two value and the tick below, so we use the tick below to make the epsilon larger.  This guarantees
            // us forward movement, but not reproducible results, so passing by arrays is important
            low = Tick1To0[iBoundary];
            ++iBoundary;
            tick *= 0.5;
            EBM_ASSERT(DBL_MIN <= tick);
         }
         return (val + tick) * k_normToSubnorm;
      } else {
         if(k_nonDoubleableTickDown < val) {
            // avoid hitting +infinity high by checking for the last doubling
            // also, if val is +inf we can't exit the loop below without this check
            return val + k_lastTick;
         }
         double high = 1.9999999999999998 /* nextafter(2.0, 0.0) */;
         double tick = k_epsilon;
         size_t iBoundary = 0;
         while(high < val) {
            EBM_ASSERT(iBoundary < sizeof(Tick2ToInf) / sizeof(Tick2ToInf[0]));
            // we use this array with tick downs from powers of two in case this function is ported without using
            // an array to pass in the values.  If this happens, the extended precision bits can be between the power
            // of two value and the tick below, so we use the tick below to make the epsilon larger.  This guarantees
            // us forward movement, but not reproducible results, so passing by arrays is important
            high = Tick2ToInf[iBoundary];
            ++iBoundary;
            tick *= 2.0;
            EBM_ASSERT(!isinf(tick));
         }
         return val + tick;
      }
   }
}

extern double TickDownInternal(double deprecisioned[1]) noexcept {
   // This is a cross-language portable implementation of nextafter

   // We pass values in as an array in order to force the elimination of any possible extended precision bits.
   double val = deprecisioned[0];

   if(isnan(val)) {
      // the rest of this function will work if IEEE-754 NaN handling is enabled, but check here for additional safety
      return val;
   }
   if(-k_minNonSubnormal < val) {
      if(val < k_minNonSubnormalTickUp) {
         if(val < k_minNonSubnormal) {
            return -k_minNonSubnormal;
         } else {
            return 0.0;
         }
      }
      if(val <= 1.0) {
         // We cannot let tick enter the subnormal range since subnormals are spaced differently from normal floats.
         // By shifting upwards through a multiple we can maintain the same spacing for the epsilons

         val *= k_subnormToNorm;
         double low = 1.0 * k_subnormToNorm * 0.5;
         double tick = k_epsilon * k_subnormToNorm * 0.5;
         while(val <= low) {
            low *= 0.5;
            tick *= 0.5;
            EBM_ASSERT(DBL_MIN <= tick);
         }
         return (val - tick) * k_normToSubnorm;
      } else {
         if(k_nonDoubleable < val) {
            // if val is +inf we can't exit the loop below without this check
            if(k_maxNonInf < val) {
               // if val is +infinity then tick down to the biggest positive number
               return k_maxNonInf;
            } else {
               // avoid hitting +infinity high by checking for the last doubling
               return val - k_lastTick;
            }
         }
         double high = 2.0;
         double tick = k_epsilon;
         while(high < val) {
            high *= 2.0;
            tick *= 2.0;
            EBM_ASSERT(!isinf(tick));
         }
         return val - tick;
      }
   } else {
      if(-0.99999999999999989 /* -nextafter(-1.0, 0.0) */ <= val) {
         // We cannot let tick enter the subnormal range since subnormals are spaced differently from normal floats.
         // By shifting upwards through a multiple we can maintain the same spacing for the epsilons

         val *= k_subnormToNorm;
         double low = -2.2517998136852478e+15 /* -nextafter(1.0 * k_subnormToNorm * 0.5, 0.0) */;
         double tick = k_epsilon * k_subnormToNorm * 0.5;
         size_t iBoundary = 0;
         while(low <= val) {
            EBM_ASSERT(iBoundary < sizeof(Tick1To0) / sizeof(Tick1To0[0]));
            // we use this array with tick downs from powers of two in case this function is ported without using
            // an array to pass in the values.  If this happens, the extended precision bits can be between the power
            // of two value and the tick below, so we use the tick below to make the epsilon larger.  This guarantees
            // us forward movement, but not reproducible results, so passing by arrays is important
            low = -Tick1To0[iBoundary];
            ++iBoundary;
            tick *= 0.5;
            EBM_ASSERT(DBL_MIN <= tick);
         }
         return (val - tick) * k_normToSubnorm;
      } else {
         if(val < -k_nonDoubleableTickDown) {
            // avoid hitting -infinity high by checking for the last doubling
            // also, if val is -inf we can't exit the loop below without this check
            return val - k_lastTick;
         }
         double high = -1.9999999999999998 /* -nextafter(2.0, 0.0) */;
         double tick = k_epsilon;
         size_t iBoundary = 0;
         while(val < high) {
            EBM_ASSERT(iBoundary < sizeof(Tick2ToInf) / sizeof(Tick2ToInf[0]));
            // we use this array with tick downs from powers of two in case this function is ported without using
            // an array to pass in the values.  If this happens, the extended precision bits can be between the power
            // of two value and the tick below, so we use the tick below to make the epsilon larger.  This guarantees
            // us forward movement, but not reproducible results, so passing by arrays is important
            high = -Tick2ToInf[iBoundary];
            ++iBoundary;
            tick *= 2.0;
            EBM_ASSERT(!isinf(tick));
         }
         return val - tick;
      }
   }
}

EBM_NATIVE_IMPORT_EXPORT_BODY void EBM_NATIVE_CALLING_CONVENTION CleanFloats(IntEbmType count, double * valsInOut) {
   // this function converts extended precision values, if they are present, into non-extended precision values by 
   // virtue of passing them in via arrays of fixed size, and it also converts subnormal values into zero, per EBM spec

   if(count < 0) {
      LOG_0(TraceLevelError, "ERROR CleanFloats count can't be negative.");
      return;
   }
   if(IsConvertError<size_t>(count)) {
      LOG_0(TraceLevelError, "ERROR CleanFloats IsConvertError<size_t>(count)");
      return;
   }
   size_t c = static_cast<size_t>(count);
   if(IsMultiplyError(sizeof(*valsInOut), c)) {
      LOG_0(TraceLevelError, "ERROR CleanFloats IsMultiplyError(sizeof(*valsInOut), c)");
      return;
   }
   while(0 != c) {
      --c;
      const double val = valsInOut[c];
      if(-std::numeric_limits<double>::min() < val && val < std::numeric_limits<double>::min()) {
         valsInOut[c] = 0.0;
      }
   }
}

#ifdef UNDEFINED_TEST_TICK_HIGHER

TEST_CASE("TickUpInternal and TickDownInternal") {
   double deprecisioned[1];

   deprecisioned[0] = NAN;
   CHECK(isnan(TickUpInternal(deprecisioned)));

   deprecisioned[0] = -std::numeric_limits<double>::infinity();
   CHECK(-DBL_MAX == TickUpInternal(deprecisioned));
   deprecisioned[0] = -DBL_MAX;
   CHECK(nextafter(-DBL_MAX, DBL_MAX) == TickUpInternal(deprecisioned));
   deprecisioned[0] = nextafter(-DBL_MAX, DBL_MAX);
   CHECK(nextafter(nextafter(-DBL_MAX, DBL_MAX), DBL_MAX) == TickUpInternal(deprecisioned));

   deprecisioned[0] = nextafter(nextafter(-DBL_MIN, -DBL_MAX), -DBL_MAX);
   CHECK(nextafter(-DBL_MIN, -DBL_MAX) == TickUpInternal(deprecisioned));
   deprecisioned[0] = nextafter(-DBL_MIN, -DBL_MAX);
   CHECK(-DBL_MIN == TickUpInternal(deprecisioned));
   deprecisioned[0] = -DBL_MIN;
   CHECK(0.0 == TickUpInternal(deprecisioned));
   deprecisioned[0] = -DBL_TRUE_MIN;
   CHECK(DBL_MIN == TickUpInternal(deprecisioned));
   deprecisioned[0] = 0.0;
   CHECK(DBL_MIN == TickUpInternal(deprecisioned));
   deprecisioned[0] = DBL_TRUE_MIN;
   CHECK(DBL_MIN == TickUpInternal(deprecisioned));
   deprecisioned[0] = DBL_MIN;
   CHECK(nextafter(DBL_MIN, DBL_MAX) == TickUpInternal(deprecisioned));
   deprecisioned[0] = nextafter(DBL_MIN, DBL_MAX);
   CHECK(nextafter(nextafter(DBL_MIN, DBL_MAX), DBL_MAX) == TickUpInternal(deprecisioned));

   deprecisioned[0] = nextafter(DBL_MAX, -DBL_MAX);
   CHECK(DBL_MAX == TickUpInternal(deprecisioned));
   deprecisioned[0] = DBL_MAX;
   CHECK(std::numeric_limits<double>::infinity() == TickUpInternal(deprecisioned));



   deprecisioned[0] = NAN;
   CHECK(isnan(TickDownInternal(deprecisioned)));

   deprecisioned[0] = -DBL_MAX;
   CHECK(-std::numeric_limits<double>::infinity() == TickDownInternal(deprecisioned));
   deprecisioned[0] = nextafter(-DBL_MAX, DBL_MAX);
   CHECK(-DBL_MAX == TickDownInternal(deprecisioned));

   deprecisioned[0] = nextafter(-DBL_MIN, -DBL_MAX);
   CHECK(nextafter(nextafter(-DBL_MIN, -DBL_MAX), -DBL_MAX) == TickDownInternal(deprecisioned));
   deprecisioned[0] = -DBL_MIN;
   CHECK(nextafter(-DBL_MIN, -DBL_MAX) == TickDownInternal(deprecisioned));
   deprecisioned[0] = -DBL_TRUE_MIN;
   CHECK(-DBL_MIN == TickDownInternal(deprecisioned));
   deprecisioned[0] = 0.0;
   CHECK(-DBL_MIN == TickDownInternal(deprecisioned));
   deprecisioned[0] = DBL_TRUE_MIN;
   CHECK(-DBL_MIN == TickDownInternal(deprecisioned));
   deprecisioned[0] = DBL_MIN;
   CHECK(0.0 == TickDownInternal(deprecisioned));
   deprecisioned[0] = nextafter(DBL_MIN, DBL_MAX);
   CHECK(DBL_MIN == TickDownInternal(deprecisioned));
   deprecisioned[0] = nextafter(nextafter(DBL_MIN, DBL_MAX), DBL_MAX);
   CHECK(nextafter(DBL_MIN, DBL_MAX) == TickDownInternal(deprecisioned));

   deprecisioned[0] = nextafter(DBL_MAX, -DBL_MAX);
   CHECK(nextafter(nextafter(DBL_MAX, -DBL_MAX), -DBL_MAX) == TickDownInternal(deprecisioned));
   deprecisioned[0] = DBL_MAX;
   CHECK(nextafter(DBL_MAX, -DBL_MAX) == TickDownInternal(deprecisioned));
   deprecisioned[0] = std::numeric_limits<double>::infinity();
   CHECK(DBL_MAX == TickDownInternal(deprecisioned));

   double base = 2 * DBL_MIN;
   do {
      double sweep = base;

      for(int i = 0; i < 5; ++i) {
         sweep = nextafter(sweep, -DBL_MAX);
      }

      for(int i = 0; i < 11; ++i) {
         deprecisioned[0] = sweep;
         double test = TickUpInternal(deprecisioned);
         sweep = nextafter(sweep, DBL_MAX);
         CHECK(sweep == test);
      }

      for(int i = 0; i < 11; ++i) {
         deprecisioned[0] = sweep;
         double test = TickDownInternal(deprecisioned);
         sweep = nextafter(sweep, -DBL_MAX);
         CHECK(sweep == test);
      }

      base *= 2.0;
   } while(!isinf(base));
}

#endif // UNDEFINED_TEST_TICK_HIGHER


// we don't care if an extra log message is outputted due to the non-atomic nature of the decrement to this value
static int g_cLogEnterCutUniformParametersMessages = 25;
static int g_cLogExitCutUniformParametersMessages = 25;

EBM_NATIVE_IMPORT_EXPORT_BODY IntEbmType EBM_NATIVE_CALLING_CONVENTION CutUniform(
   IntEbmType countSamples,
   const double * featureValues,
   IntEbmType countDesiredCuts,
   double * cutsLowerBoundInclusiveOut
) {
   // DO NOT CHANGE THIS FUNCTION'S ALGORITHM.  IT IS PART OF THE EBM HISTOGRAM SPEC
   //
   // This function is used when choosing histograms cuts. Since we don't store the histogram 
   // cuts in our JSON, this function must always return the same results in all implementations.
   //
   // This function guarantees that it will return countDesiredCuts unless it is impossible to put enough cuts between
   // the min and max values, and in that case it will put a cut into every possible location allowed by floats.
   // This functionality is required because if we have a given number of histogram counts, then we need
   // to return the corresponding number of expected cuts, so returning the maximum number of cuts allowed avoids
   // issues because our caller would have to throw an exception if they got back less cuts than expected.
   // 
   // When later discretizing, we include numbers equal to the cut in the bin because we want
   // a cut of 1.0 to include 1.0 in the same bin as 1.999999... (if the next cut is at 2.0)
   //
   // This means we never return the min value in our cuts since that will be 
   // separated from the min value by the next highest floating point number.
   //
   // This also means that we can return a cut at the max value since a cut there will keep
   // the max value in the highest bin, so we do have an asymmetry that we fundamentally can't 
   // avoid since we need to make a choice whether exact matches fall into the lower or upper bin.
   //
   // Since our cuts can include the max value, this means that we cannot separate +highest from +inf values without 
   // allowing a +inf cut value, which we don't want to do. So, +inf values get converted to +highest
   // before choosing the cuts.  It would be hard to do anything else anyways since +inf is hard to use.
   //
   // For symmetry, we set -inf to lowest before generating uniform cuts.
   //
   // For histograms edges, our caller will add the min and max values to the returned cuts. We do include
   // -inf and +inf values there, so we still preserve the best information when graphing and serializing.
   //
   // We do not allow cut points to be subnormal floats. Even if we can handle subnormals ourselves here, other 
   // callers might not be able to handle them.  They might not serialize to JSON or work in JavaScript, etc.
   //
   // This function should be able to return reproducible results in all environments that I'm aware of. In order 
   // for us to return reproducible results we require:
   //   - That the numbers are stored in IEEE-754 format, which has been the case for all common CPUs since the 1980s.
   //   - The numbers in this file are converted into their exact IEEE-754 representation, which is a requirement 
   //     of the original IEEE-754 spec for numbers given with 17 digits of precision.  I am not aware of an
   //     implementation that violates this, although there are implementations that differ for shorter numbers
   //     than 17 digits which requires exact rounding.  We always provide 17 digits here, unless a number has
   //     an exact float representation (eg: 2.0 or 0.5).
   //   - We require that we can eliminate any extended precision digits.  Generally this can be done by storing
   //     any values in memory since then they need to have defined sizes.  The only processor I am aware of
   //     that uses extened precision is the original x86 floating point unit, but you can now specify for most
   //     compilers (which we have done) to use the SSE2 registers, which do not use extended precision. SSE2 registers
   //     are always available in 64 bit more, and have been avilable since the year 2000 in 32 bit mode.
   //   - We require exact rounding for addition, subtraction, division and multiplication.  The original IEEE-754
   //     required correct rounding for these operations, and I'm not aware of an implementation that violates this
   //   - We require that the IEEE-754 rounding mode is set to "Round to nearest, ties to even".  This is the default
   //     IEEE-754 rounding mode, and I'm not aware of any programming language environment that sets it to anything 
   //     other than that by default.
   // If these are violated, then the results cannot be guaranteed to be reproducible, but even then they should
   // almost always be reproducible except in outlier cases, and they should only be off by the least significant
   // float bit, except for very large numbers where we'd still be close.  We do guarantee that we return the same 
   // number of cuts in all cases, and that we will fill all legal cuts when the difference between the min and 
   // max value is insuficient to have enough cuts.

   LOG_COUNTED_N(
      &g_cLogEnterCutUniformParametersMessages,
      TraceLevelInfo,
      TraceLevelVerbose,
      "Entered CutUniform: "
      "countSamples=%" IntEbmTypePrintf ", "
      "featureValues=%p, "
      "countDesiredCuts=%" IntEbmTypePrintf ", "
      "cutsLowerBoundInclusiveOut=%p"
      ,
      countSamples,
      static_cast<const void *>(featureValues),
      countDesiredCuts,
      static_cast<void *>(cutsLowerBoundInclusiveOut)
   );

   if(countDesiredCuts <= 0) {
      if(countDesiredCuts < 0) {
         LOG_0(TraceLevelError, "ERROR CutUniform countDesiredCuts can't be negative.");
      } else {
         LOG_COUNTED_0(
            &g_cLogExitCutUniformParametersMessages,
            TraceLevelInfo,
            TraceLevelVerbose,
            "Exited CutUniform: countCuts=0 due to zero countDesiredCuts"
         );
      }
      return 0;
   }
   if(IsConvertError<size_t>(countDesiredCuts)) {
      LOG_0(TraceLevelError, "ERROR CutUniform IsConvertError<size_t>(countDesiredCuts)");
      return 0;
   }
   const size_t cCuts = static_cast<size_t>(countDesiredCuts);
   if(IsMultiplyError(sizeof(*cutsLowerBoundInclusiveOut), cCuts)) {
      LOG_0(TraceLevelError, "ERROR CutUniform countDesiredCuts was too large to fit into cutsLowerBoundInclusiveOut");
      return 0;
   }

   if(countSamples <= 1) {
      if(countSamples < 0) {
         LOG_0(TraceLevelError, "ERROR CutUniform countSamples < IntEbmType { 0 }");
      } else {
         LOG_COUNTED_0(
            &g_cLogExitCutUniformParametersMessages,
            TraceLevelInfo,
            TraceLevelVerbose,
            "Exited CutUniform: countCuts=0 because we can't cut 1 sample"
         );
      }
      return 0;
   }
   if(IsConvertError<size_t>(countSamples)) {
      LOG_0(TraceLevelError, "ERROR CutUniform IsConvertError<size_t>(countSamples)");
      return 0;
   }
   const size_t cSamples = static_cast<size_t>(countSamples);
   if(IsMultiplyError(sizeof(*featureValues), cSamples)) {
      LOG_0(TraceLevelError, "ERROR CutUniform countSamples was too large to fit into featureValues");
      return 0;
   }

   if(nullptr == featureValues) {
      LOG_0(TraceLevelError, "ERROR CutUniform nullptr == featureValues");
      return 0;
   }

   double minValue = std::numeric_limits<double>::max();
   double maxValue = std::numeric_limits<double>::lowest();

   const double * pValue = featureValues;
   const double * const pValuesEnd = featureValues + cSamples;
   do {
      const double val = *pValue;
      // use this check for NaN for cross-language portability.  Not needed in C++ with appropriate compiler flags
      if(!isnan(val)) {
         maxValue = maxValue < val ? val : maxValue; // this works for NaN values which evals to false
         minValue = val < minValue ? val : minValue; // this works for NaN values which evals to false
      }
      ++pValue;
   } while(pValuesEnd != pValue);

   EBM_ASSERT(!std::isnan(minValue));
   EBM_ASSERT(!std::isnan(maxValue));

   EBM_ASSERT(-std::numeric_limits<double>::infinity() != maxValue);
   EBM_ASSERT(std::numeric_limits<double>::infinity() != minValue);

   if(std::numeric_limits<double>::max() == minValue && std::numeric_limits<double>::lowest() == maxValue) {
      LOG_COUNTED_0(
         &g_cLogExitCutUniformParametersMessages,
         TraceLevelInfo,
         TraceLevelVerbose,
         "Exited CutUniform: countCuts=0 due to all feature values being missing"
      );
      return 0;
   }

   if(minValue <= std::numeric_limits<double>::lowest()) {
      minValue = std::numeric_limits<double>::lowest();
   }

   if(std::numeric_limits<double>::max() <= maxValue) {
      maxValue = std::numeric_limits<double>::max();
   }

   double deprecisioned[1];

   // make it zero if our caller gave us a subnormal
   deprecisioned[0] = minValue;
   CleanFloats(1, deprecisioned);
   minValue = deprecisioned[0];

   deprecisioned[0] = maxValue;
   CleanFloats(1, deprecisioned);
   maxValue = deprecisioned[0];

   if(minValue == maxValue) {
      LOG_COUNTED_0(
         &g_cLogExitCutUniformParametersMessages,
         TraceLevelInfo,
         TraceLevelVerbose,
         "Exited CutUniform: countCuts=0 due to there being only 1 unique value"
      );
      return 0;
   }
   EBM_ASSERT(minValue < maxValue);

   if(nullptr == cutsLowerBoundInclusiveOut) {
      // if we have a potential bin cut, then cutsLowerBoundInclusiveOut shouldn't be nullptr
      LOG_0(TraceLevelError, "ERROR CutUniform nullptr == cutsLowerBoundInclusiveOut");
      return 0;
   }

   double walkValue = minValue;
   size_t iCut = 0;
   do {
      EBM_ASSERT(walkValue < maxValue);
      deprecisioned[0] = walkValue;
      walkValue = TickUpInternal(deprecisioned);
      cutsLowerBoundInclusiveOut[iCut] = walkValue;
      ++iCut; // increment here so that we return the right # of items in the if statement below
      if(walkValue == maxValue) {
         const IntEbmType countCutsRet = static_cast<IntEbmType>(iCut);
         EBM_ASSERT(countCutsRet <= countDesiredCuts);

         LOG_COUNTED_N(
            &g_cLogExitCutUniformParametersMessages,
            TraceLevelInfo,
            TraceLevelVerbose,
            "Exited CutUniform: "
            "countCuts=%" IntEbmTypePrintf
            ,
            countCutsRet
         );

         return countCutsRet;
      }
   } while(cCuts != iCut);

   EBM_ASSERT(walkValue < maxValue);

   // at this point we can guarantee that we can return countDesiredCuts items since we were able to 
   // fill that many cuts into the buffer.  We could return at any time now with a legal representation
   // if we found ourselves in a situation where we needed to

   // we checked that cCuts can be multiplied with sizeof(*cutsLowerBoundInclusiveOut), and since
   // there is no way an element of cutsLowerBoundInclusiveOut is as small as 1 byte, we should
   // be able to add one to cCuts
   EBM_ASSERT(!IsAddError(size_t { 1 }, cCuts));
   // don't take the reciprocal here because dividing below will be more accurate when rounding
   const size_t cBins = cCuts + 1;
   const double cBinsFloat = static_cast<double>(cBins);

   // if maxValue is max_float and minValue is min_float those values are represented with mantissas of all
   // 1s and exponents one shy of all 1s.  Dividing by 2.0 reduces the exponent, but keeps all the mantissa bits.
   // Then subtracting the two equally negated results is identical to multiplying by 2.0, which gives back the 
   // original values.  No rounding was required, so it doesn't matter which IEEE-754 rounding mode is enabled
   // We never overflow to +inf.
   double halfDiff = maxValue / 2.0 - minValue / 2.0;
   EBM_ASSERT(!std::isinf(halfDiff));

   // check for greater than the tick below the value that makes +inf when doubled so that if there are
   // extended precision bits, we are conservative and use the big number handling
   if(k_nonDoubleableTickDown < halfDiff) {
      EBM_ASSERT(2.0 <= cBinsFloat);
      double stepValue = maxValue / cBinsFloat - minValue / cBinsFloat;

      // if maxValue is max_float and minValue is min_float those values are represented with mantissas of all
      // 1s and exponents one shy of all 1s.  Dividing by 2.0 reduces the exponent, but keeps all the mantissa bits.
      // Then subtracting the two equally negated results is identical to multiplying by 2.0, which gives back the 
      // original values.  No rounding was required, so it doesn't matter which IEEE-754 rounding mode is enabled
      // We never overflow to +inf.
      EBM_ASSERT(!std::isinf(stepValue));
      // stepValue cannot be a subnormal since the range of a float64 is larger than an int64
      EBM_ASSERT(std::numeric_limits<double>::min() <= stepValue);

      // the first cut should always succeed, since we subtract from maxValue, so even if 
      // the subtraction is zero we succeed in having a cut at maxValue, which is legal for us
      double cutPrev = std::numeric_limits<double>::max();
      EBM_ASSERT(cCuts == iCut);
      do {
         double cut;
         const size_t iReversed = cBins - iCut;

         // the stepValue multiple cannot be subnormal since stepValue cannot be subnormal, 
         // but call Denormalize anyways to guarantee that fused multiply add instructions are not used

         // if we go beyond the mid-point index, then (i * stepValue) can overflow, so we need to swap our anchor
         if(iCut < iReversed) {
            // always subtract from maxValue on the first iteration so that
            // cutPrev has a guarantee that it's maxValue or lower
            EBM_ASSERT(2 <= iReversed);

            double shift = static_cast<double>(iCut) * stepValue;
            EBM_ASSERT(!std::isinf(shift));
            deprecisioned[0] = shift;
            CleanFloats(1, deprecisioned);
            shift = deprecisioned[0];
            EBM_ASSERT(!std::isinf(shift));
            cut = minValue + shift;
            EBM_ASSERT(!std::isinf(cut));
         } else if(iCut == iReversed) {
            // Special case this since we're at our extreme difference between the two ends, so average them.
            // If we don't do this we can reach to +inf if max is max_float and min is lowest_float and our step is
            // rounded upwards.  This can happen if the number of cuts is odd, but not even.

            // this cannot overflow to +-inf since one of them needs to be positive and the other negative
            // to have gotten here where we consider huge diff ranges close to infinity
            cut = maxValue / 2.0 + minValue / 2.0;
            EBM_ASSERT(!std::isinf(cut));
         } else {
            double shift = static_cast<double>(iReversed) * stepValue;
            EBM_ASSERT(!std::isinf(shift));
            deprecisioned[0] = shift;
            CleanFloats(1, deprecisioned);
            shift = deprecisioned[0];
            EBM_ASSERT(!std::isinf(shift));
            cut = maxValue - shift;
            EBM_ASSERT(!std::isinf(cut));
         }

         deprecisioned[0] = cut;
         CleanFloats(1, deprecisioned);
         cut = deprecisioned[0];

         if(cutPrev <= cut && 1 != iReversed) {
            // if we didn't advance, then don't put the same cut into the result, advance by one tick
            deprecisioned[0] = cutPrev;
            cut = TickDownInternal(deprecisioned);
         }

         if(cut <= cutsLowerBoundInclusiveOut[iCut - 1]) {
            // if this happens, the rest of our cuts will be at tick increments, which we've already filled in
            break;
         }
         cutsLowerBoundInclusiveOut[iCut - 1] = cut;

         cutPrev = cut;
         --iCut;
      } while(0 != iCut);
   } else {

      // This algorithm has some not as nice properties around subnormal numbers.  Specifically, when a cut
      // lands in the large subnormal space we flush it to zero, and our ticks are limited to non-subnormal numbers
      // too.  This can lead to bunching on float tick increment boundaries where we have more ability to preserve
      // float resolution.  We might be able to make this situation better through difficult manipulation, but this
      // "spec" algorithm is already complicated enough, and we want it to be portable accross implementations without
      // being even more complicated, so our solution here is simply to accept the undesirable bunching around
      // subnormal numbers. We cannot fundamentally have good uniform cuts near subnormals anyways since the big
      // subnormal gap does exists and we can't avoid that while disallowing subnormals as cuts.  The real solution
      // is for the user to avoid spans in the range of 10e-308.  These should be quite rare in any case.
      // This algorithm as constructed has the benefit of being reproducible in any environment that is IEEE-754
      // compliant, minus subnormal compliance.


      // our shift value below can enter the subnormal range which can cause problems in some environments
      // we can solve these issues by shifting upwards to the highest numbers that do not overflow

      double diff;

      double maxValueCur;
      double multipleCur;
      double minValueCur;

      double maxValueNext = maxValue;
      double minValueNext = minValue;
      double multipleNext = 1.0;

      while(true) {
         diff = maxValueNext - minValueNext;
         EBM_ASSERT(!std::isinf(diff));

         maxValueCur = maxValueNext;
         multipleCur = multipleNext;
         minValueCur = minValueNext;

         if(k_nonDoubleableTickDown < fabs(maxValueNext)) {
            break;
         }
         if(k_nonDoubleableTickDown < multipleNext) {
            break;
         }
         if(k_nonDoubleableTickDown < fabs(minValueNext)) {
            break;
         }
         multipleNext = multipleCur * 2.0;
         EBM_ASSERT(!std::isinf(multipleNext));
         maxValueNext = maxValue * multipleNext;
         EBM_ASSERT(!std::isinf(maxValueNext));
         minValueNext = minValue * multipleNext;
         EBM_ASSERT(!std::isinf(minValueNext));

         // the diff changes at a different rate so check after increasing the min & max 
         // this cannot overflow, per notes above when we do this for the entire range
         // since this operation does not round in IEEE-754
         double halfDiffNext = maxValueNext / 2.0 - minValueNext / 2.0;
         EBM_ASSERT(!std::isinf(halfDiffNext));
         if(k_nonDoubleableTickDown < halfDiffNext) {
            break;
         }
      }

      deprecisioned[0] = diff;
      CleanFloats(1, deprecisioned);
      diff = deprecisioned[0];

      if(std::abs(minValue) < std::abs(maxValue)) {
         // minValue has more precision, so anchor to that point

         // We're going to fill the cut buffer upwards from the minValue to the maxValue.  If we find that 
         // we hit the boundary where the rest of the cuts need to be in tick increments then we want 
         // it to be in the less precise range near the maxValue, so let's re-fill our buffer again starting 
         // from the maxValue and work downwards by ticks so that we can bail with valid results if needed

         EBM_ASSERT(cCuts == iCut);
         walkValue = maxValue;
         do {
            EBM_ASSERT(minValue < walkValue);
            cutsLowerBoundInclusiveOut[iCut - 1] = walkValue;
            deprecisioned[0] = walkValue;
            walkValue = TickDownInternal(deprecisioned);
            --iCut;
         } while(0 != iCut);

         // if they are equal then we should have exited above when filling the buffer initially
         EBM_ASSERT(minValue < walkValue);

         double cutPrev = minValue;
         EBM_ASSERT(0 == iCut);

         do {
            ++iCut;

            // we need to de-subnormalize the shift to get cross machine compatibility since some machines
            // flush subnormals to zero, although this introduces bunching around the start point if
            // that's a very small number close to the subnormals, but I'm not sure there is a solution there
            double shift = static_cast<double>(iCut) / cBinsFloat * diff;

            deprecisioned[0] = shift;
            CleanFloats(1, deprecisioned);
            shift = deprecisioned[0];

            double cut = minValueCur + shift;

            deprecisioned[0] = cut;
            CleanFloats(1, deprecisioned);
            cut = deprecisioned[0];

            cut /= multipleCur;

            deprecisioned[0] = cut;
            CleanFloats(1, deprecisioned);
            cut = deprecisioned[0];

            // TODO: Consider implementing the algorithm below.. although it's not clear to me that the benefit
            //       Outweights the added complexity of doing so.  The band gap problem only affects numbers in
            //       the range of e-307 or so, and even if we are in that range we still provide reproducible results
            //       It's just that there may be bunching on one side of the subnormal gap.
            //if(0.0 == cut) {
            //   if(0.0 == Denormalize(diffCur / multipleCur / cBinsFloat)) {
            //      // if our individual steps are less than float_min then we know that -min, 0, and +min are all
            //      // going to be cut points provided we're crossing the 0 band gap.  If the steps are greater than
            //      // float_min then we can trust float rounding to decide which of the -min, 0, or +min values
            //      // will be included.  The underflow condition is harder though because we originally spaced
            //      // our ticks believing there wouldn't be a big gap (in the subnormal space), so we need
            //      // to reconsider this.  We can no longer really provide a uniform set of cuts, so the best
            //      // we can do now is put cuts at -min, 0, and +min and then fill in the cuts on each side of the gap.
            //      return HandleSubnormalGap(...);
            //   }
            //}

            if(cut <= cutPrev) {
               // if we didn't advance, then don't put the same cut into the result, advance by one tick
               deprecisioned[0] = cutPrev;
               cut = TickUpInternal(deprecisioned);
            }

            if(cutsLowerBoundInclusiveOut[iCut - 1] <= cut) {
               // if this happens, the rest of our cuts will be at tick increments, which we've already filled in
               break;
            }
            cutsLowerBoundInclusiveOut[iCut - 1] = cut;

            cutPrev = cut;
         } while(cCuts != iCut);
      } else {
         // maxValue has more precision, so anchor to that point

         // the first cut should always succeed, since we subtract from maxValue, so even if 
         // the subtraction is zero we succeed in having a cut at maxValue, which is legal for us
         double cutPrev = std::numeric_limits<double>::max();
         EBM_ASSERT(cCuts == iCut);

         do {
            const size_t iReversed = cBins - iCut;

            // we need to de-subnormalize the shift to get cross machine compatibility since some machines
            // flush subnormals to zero, although this introduces bunching around the start point if
            // that's a very small number close to the subnormals, but I'm not sure there is a solution there
            double shift = static_cast<double>(iReversed) / cBinsFloat * diff;

            deprecisioned[0] = shift;
            CleanFloats(1, deprecisioned);
            shift = deprecisioned[0];

            double cut = maxValueCur - shift;

            deprecisioned[0] = cut;
            CleanFloats(1, deprecisioned);
            cut = deprecisioned[0];

            cut /= multipleCur;

            deprecisioned[0] = cut;
            CleanFloats(1, deprecisioned);
            cut = deprecisioned[0];

            // TODO: Consider implementing the algorithm below.. although it's not clear to me that the benefit
            //       Outweights the added complexity of doing so.  The band gap problem only affects numbers in
            //       the range of e-307 or so, and even if we are in that range we still provide reproducible results
            //       It's just that there may be bunching on one side of the subnormal gap.
            //if(0.0 == cut) {
            //   if(0.0 == Denormalize(diffCur / multipleCur / cBinsFloat)) {
            //      // if our individual steps are less than float_min then we know that -min, 0, and +min are all
            //      // going to be cut points provided we're crossing the 0 band gap.  If the steps are greater than
            //      // float_min then we can trust float rounding to decide which of the -min, 0, or +min values
            //      // will be included.  The underflow condition is harder though because we originally spaced
            //      // our ticks believing there wouldn't be a big gap (in the subnormal space), so we need
            //      // to reconsider this.  We can no longer really provide a uniform set of cuts, so the best
            //      // we can do now is put cuts at -min, 0, and +min and then fill in the cuts on each side of the gap.
            //      return HandleSubnormalGap(...);
            //   }
            //}

            if(cutPrev <= cut && 1 != iReversed) {
               // if we didn't advance, then don't put the same cut into the result, advance by one tick
               deprecisioned[0] = cutPrev;
               cut = TickDownInternal(deprecisioned);
            }

            if(cut <= cutsLowerBoundInclusiveOut[iCut - 1]) {
               // if this happens, the rest of our cuts will be at tick increments, which we've already filled in
               break;
            }
            cutsLowerBoundInclusiveOut[iCut - 1] = cut;

            cutPrev = cut;
            --iCut;
         } while(0 != iCut);
      }
   }

   LOG_COUNTED_N(
      &g_cLogExitCutUniformParametersMessages,
      TraceLevelInfo,
      TraceLevelVerbose,
      "Exited CutUniform: "
      "countCuts=%" IntEbmTypePrintf
      ,
      countDesiredCuts
   );

   return countDesiredCuts;
}

} // DEFINED_ZONE_NAME
